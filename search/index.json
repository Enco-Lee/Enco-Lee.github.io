[{"content":"拷贝构造和拷贝赋值 之前阅读C++的书籍中拷贝构造和拷贝赋值相关章节时， 看到一些例子时总会纳闷， 比如 :\n1 string s1 = s2; // 为什么这里是拷贝构造， 而不是拷贝赋值 ？ 也就是之前一直分不清一个问题： 在不考虑移动构造和移动赋值的情况下， 使用=操作对象时是调用了拷贝构造还是拷贝赋值运算符？\n现在明白了： 主要看=左边的对象之前有没有构造好，左边的对象已经构造好了，就是调用拷贝赋值运符，否则使用的是拷贝构造。\n举例：\n1 2 3 4 5 Object a; Object b = a; // b之前没有构造好，这里用的是拷贝构造 Object c; c = a; // c之前已经构造好了，现在用的是拷贝赋值运算符 ","date":"2024-06-01T13:58:02+08:00","permalink":"https://Enco-Lee.github.io/p/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%96%91%E9%97%AE/","title":"一个关于拷贝构造和拷贝赋值运算符的疑问"},{"content":"vs code 下载clang-format插件(如果是远程开发,需要为远程主机vs code 服务端下载该插件) 确认是否安装clang-format（如果是远程开发，远程主机也需要clang-format程序）, windows环境需要确认是否将clang-format所在文件夹配置进环境变量 Shlft + Alt + F快捷键可格式化文件，默认情况下Ctrl + S保存时将自动格式化 Visual studio code 安装Clang Power Tools 插件 靠近右上角插件tool bar栏目，设置中打开保存自动格式化 ","date":"2024-05-13T01:44:55+08:00","permalink":"https://Enco-Lee.github.io/p/clang-format%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/","title":"clang-format自动格式化代码"},{"content":"0x01 问题分析 在\u0026laquo;Effective STL\u0026raquo;条目18中曾提到要避免使用vector\u0026lt;bool\u0026gt;\n分析 vector\u0026lt;bool\u0026gt;不能算标准容器，标准容器要满足： T* p = \u0026amp;vec[0]可编译, 而它不满足：\n1 2 3 vector\u0026lt;bool\u0026gt; vec(100， false); bool* bp = \u0026amp;vec[0]; // error, 提示类型对不上 bool\u0026amp; br = vec[0]; // error vector\u0026lt;bool\u0026gt;考虑到空间上的优化，它存的不是直接存的bool类型，而是一个个bit，相当于可动态扩容的bitset。\n[]返回的是一个reference, 导致当元素赋值给auto变量并存在修改auto变量时，会影响容器中的内容（这个需要特别小心）：\n1 2 3 4 5 vector\u0026lt;bool\u0026gt; vec(100, false); auto a = vec[0]; std::cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt;vec[0] \u0026lt;\u0026lt; endl; // false a = true; std::cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; vec[0] \u0026lt;\u0026lt; endl; // true bool b = vec[0];没问题是由于有隐式类型转换。\n小结 通过上面的分析总结vector\u0026lt;bool\u0026gt;存在两个小坑（问题）：\nbool指针（引用）没法直接指向元素 元素赋值给auto变量，修改该变量会影响容器中元素 0x02 替代方案 不需要动态扩容可以考虑使用array (PS: array似乎被人遗忘了，刷题中上场率不高~):\n1 2 array\u0026lt;bool, 100\u0026gt; vis; fill(vis.begin(), vis.end(), false); 可以使用vector\u0026lt;unsigned int\u0026gt;:\n1 2 3 4 5 6 7 using mbool = unsigned int; vector\u0026lt;mbool\u0026gt; vis(100, false); cout \u0026lt;\u0026lt;vis[0] \u0026lt;\u0026lt; endl; // 0 auto b = vis[0]; // 主要是这里 降低了误修改容器值的概率 b = true; cout \u0026lt;\u0026lt;vis[0] \u0026lt;\u0026lt; endl; // 0 // 由于不是真正的bool所以不支持\u0026lt;\u0026lt;boolalpha直接显示true,false 使用dequeue：\n除了reserver(因为内存不必连续，它根本不需要这个操作)，基本上vector能做的操作它都可以做。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int n; cin \u0026gt;\u0026gt; n; deque\u0026lt;bool\u0026gt; vis(n, false); //vis.assign(100, false); // ok cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; vis[0] \u0026lt;\u0026lt; endl; // false auto b = vis[0]; b = true; cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; vis[0] \u0026lt;\u0026lt; endl; // false bool* bp = \u0026amp;vis[0]; // ok bool\u0026amp; br = vis[1]; // ok br = true; cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; vis[1] \u0026lt;\u0026lt; endl; // true for (auto\u0026amp;\u0026amp; v : vis) { cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; 如果真的有必要，个人更倾向第1种和第3种替代方案， 第2种反直觉且不方便。\n0x03 注意 并不能为了避免上面提到的vector\u0026lt;bool\u0026gt;存在的问题而用bitset来替代， 因为前面已经提到vector\u0026lt;bool\u0026gt;相当于可动态扩容的bitset，而且bitset并没有基于范围的for循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 bitset\u0026lt;100\u0026gt; bits; bits.set(0); // =\u0026gt; bits[0] = true cout \u0026lt;\u0026lt; std::boolalpha\u0026lt;\u0026lt;bits[0] \u0026lt;\u0026lt; endl; bits.reset(0); // =\u0026gt; bits[0] = false cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; bits[0] \u0026lt;\u0026lt; endl; bits[1] = true; cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; bits[1] \u0026lt;\u0026lt; endl; // true bits[1].flip(); cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; bits[1] \u0026lt;\u0026lt; endl; // false auto b = bits[1]; // reference b = true; cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; bits[1] \u0026lt;\u0026lt; endl; // true for (auto b : bits) // error { } bitset可以方便操作bit位，它转换成string 和unsigned long的接口也很强大：\nto_string to_ulong to_ullong ","date":"2022-09-23T21:21:00+08:00","permalink":"https://Enco-Lee.github.io/p/bool%E7%B1%BB%E5%9E%8Bvector%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/","title":"bool类型vector存在的问题以及替代方案"},{"content":"","date":"2022-09-23T21:14:00+08:00","permalink":"https://Enco-Lee.github.io/p/malloc%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","title":"malloc底层实现"},{"content":"洗牌算法 假设有n个元素的序列，要对它们shuffle\nFisher-Yates洗牌基本思路： 从下标[curIndex, n)随机选一个使其对应的数字和当前下标curIndex的数字进行交换 代码实现： 1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; shuffle(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i = 0; i \u0026lt; n; ++i) { int randIndex = i + rand() % (n - i); // 在[curIndex, n)之间 std::swap(nums[i], nums[randIndex]); } return nums; } 每个元素都等概率出现在任一位置（或者说：每一种排列都等概率的出现）证明：\n因为显然有：任一元素在第1个位置的概率为: $$ \\frac{1}{n} $$\n任一元素第2个位置的概率为： $$ \\frac{n-1}{n} * \\frac{1}{n - 1} = \\frac{1}{n} $$\n任一元素第3个位置的概率为： $$ \\frac{n-1}{n} * \\frac{n-2}{n - 1} * \\frac{1}{n - 2} = \\frac{1}{n} $$ \u0026hellip;\n所以每个元素都等概率出现在任一位置。\n全排序算法 假设有n个元素的序列， 返回它的所有可能排序，可以按照任意顺序\n基本思想： 我们看成填一个长度为n的序列， 从左往右每一个位置每次选一个没有使用过的元素填入\n版本1：\n以前我经常通过借助一个bool数组来标记元素是否使用, 具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;bool\u0026gt; vis(n, false); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ret; vector\u0026lt;int\u0026gt; item; function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int curCount) { if(curCount == n) { ret.push_back(item); return; } for(int i = 0; i \u0026lt; n; ++i) { if(vis[i]) continue; vis[i] = true; item.push_back(nums[i]); dfs(curCount + 1); item.pop_back(); vis[i] = false; } }; dfs(0); return ret; } }; 版本2：\n现在我一般会这么实现（一方面空间复杂度更优，另一方面写起来也更简洁\u0026hellip;）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ret; function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int curIndex) { if(curIndex == n-1) // 这里写n也是可以，但是没有必要，因为它后面没有其他元素可swap { ret.push_back(nums); return; } for(int i = curIndex; i \u0026lt; n; ++i) // [curIndex, n), 和前面提到的shuffle一致！！！ { std::swap(nums[curIndex], nums[i]); dfs(curIndex + 1); std::swap(nums[curIndex], nums[i]); } }; dfs(0); return ret; } }; 版本二代码 关键过程 现在我是 通过 Fisher-Yates洗牌思路来理解记忆。\n当然，版本二也可以这样理解，将序列看成两部分：\n一部分已经确定下来了：前面部分[0, curIndex)已经确定了 另一部分没有确定下来： 那就对后面部分[curIndex, n)全排列， 可通过每一个元素和curIndex处元素交换来实现，递归返回时交换回来。 总结 洗牌本身要求就是每一种排列都等概率的出现，而全排列就是把每一种排列枚举出来。 如果你发现了前面提到的Fisher-Yates洗牌和版本2的全排列的相同之处，相信以后你只要会两者中之一， 那么两者大概率都能够实现出来。 对于全排列算法，涉及到全排列的去重，字典序，非递归写法（字典序求解下一个排列），我以前有个简单总结：Algorithm of permutation(全排列算法)。 ","date":"2022-09-21T23:36:00+08:00","permalink":"https://Enco-Lee.github.io/p/%E6%B4%97%E7%89%8C%E5%92%8C%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E8%81%94%E7%B3%BB/","title":"洗牌和全排列的联系"},{"content":"构造时初始化为指定值 1 2 3 int n = 100; std::vector\u0026lt;int\u0026gt; v(n); // 未指定值时，底层调用memset初始化n个0 std::vector\u0026lt;int\u0026gt; vec(n, 1); 成员函数assign 1 2 3 4 5 6 // n = 100 std::vector\u0026lt;int\u0026gt; vec2; vec2.assign(n, 0);// 如果n比原来capacity大，则重新分配更大的内存，然后初始化为指定的值 std::cout \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; std::endl; // 100, 100 vec.assign(50, 2); // new size \u0026lt; old size, 会resize，多的部分元素会调用析构函数 std::cout \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; std::endl; // 50, 50 借助填充算法 填充为相同的值 基本用法\nstd::fill(firstIterator, lastIterator, value) std::fill_n(firstIterator, n, value) 定义在头文件\u0026lt;algorithm\u0026gt;中\n实例：\n1 2 fill(vec.begin(), vec.end(), 1); fill_n(vec.begin(), vec.size(), 3); iota填充为一个序列 c++11提供的算法,定义在头文件\u0026lt;numeric\u0026gt;中 定义： 1 2 template\u0026lt; class ForwardIt, class T \u0026gt; void iota( ForwardIt first, ForwardIt last, T value ); 实例： 1 2 int startValue = 1; std::iota(vec.begin(), vec.end(), startValue); // startValue, startValue+1...startValue+vec.size() ","date":"2022-09-18T23:54:00+08:00","permalink":"https://Enco-Lee.github.io/p/vector%E5%87%A0%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/","title":"vector几种初始化方式"},{"content":"画线算法 简单的画线算法 根据直线方程两点式：\n$$ \\frac{(x - x_0)}{(x_1 - x_0)} = \\frac{(y - y_0)}{(y_1 - y_0)} = t, t \\in [0, 1] $$ 那么有： $$ x = t * (x_1 - x_0) + x_0 = (1- t) * x_0 + x_1 \\ y = t * (y_1 - y_0) + y_0 = (1- t) * y_0 + y_1 $$\n则画线的算法代码为：\n1 2 3 4 5 6 7 8 9 10 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { float dt = 0.01; for (float t = 0; t \u0026lt;= 1.0; t += dt) { int x = (1 - t) * x0 + t * x1; int y = (1 - t) * y0 + t * y1; image.set(x, y, color); } } 上述代码绘制效果：\n当dt = 0.1时，画出的却是一些离散的点：\n上述算法缺点：\n效率比较低，有比较多浮点数运算 dt取值太小容易出现重复计算，dt太大会出现断裂 如何确定一个合适的步长dt呢？\n很明显它和我们需要绘制多少个像素相关： 我们的步长每次增加一个像素长度，那么我们可以写出下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { // 线性插值: 已知x求解y // (x - x0) / (x1 - x0) = (y - y0) / (y1- y0) = t // =\u0026gt; y = t * (y1 - y0) + y0 = (1 - t) * y0 + t * y1 for (int x = x0; x \u0026lt;= x1; ++x) { float t = (x - x0) / static_cast\u0026lt;float\u0026gt;(x1 - x0); int y = (1.0f - t) * y0 + t * y1; image.set(x, y, color); } } 上述代码绘制效果：\n1 2 3 4 // 以下所有绘制直线都采用这三行代码测试 line(13, 20, 80, 40, image, red); line(20, 13, 40, 80, image, white); line(80, 40, 13, 20, image, white); 结果分析：\n第二条比较陡峭的白线没有达到预期出现了断裂: 由于$|dx| \u0026lt; |dy|$, $x$每增加1，$y$需要变化比较大 第三条实际上是和第一条一样的线，只是方向不一样却没有绘制出来，否则应该会覆盖掉第一条红色的线 修复后代码：（由后面DDA算法的实现，可以看出下方代码可以说是DDA的另一种实现，不同点只是借助线性插值的方式计算出增量后的y）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { bool steep = false; if (abs(x0 - x1) \u0026lt; abs(y0 - y1))// |dx| \u0026lt; |dy|， 转置 { steep = true; std::swap(x0, y0); std::swap(x1, y1); } if (x0 \u0026gt; x1) // 起点到终点为从左到右 { std::swap(x0, x1); std::swap(y0, y1); } // 线性插值: 已知x求解y // (x - x0) / (x1 - x0) = (y - y0) / (y1- y0) = t // =\u0026gt; y = t * (y1 - y0) + y0 = (1- t) * y0 + t * y1 for (int x = x0; x \u0026lt;= x1; ++x) { float t = (x - x0) / static_cast\u0026lt;float\u0026gt;(x1 - x0); int y = (1.0f - t) * y0 + t * y1; if (steep) { image.set(y, x, color); // 转置回来 } else { image.set(x, y, color); } } } 性能分析：\npass\n循环内有较多浮点数运算，效率比较低。\nDDA 算法 数值微分法:(Digital Differential Analyzer) DDA\n我们从直线截距式来看： $$ y = kx + b \\ 同时有：x = (y-b) / k $$\n很明显有：\n当$x$增量为$1$时，$y$增量为$k = dy/dx$; 当$y$增量为$1$时， $x$增量为$1/k = dx/dy$ 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { int dx = x1 - x0; int dy = y1 - y0; int steps = abs(dx); float x = x0; float y = y0; float incx = dx / static_cast\u0026lt;float\u0026gt;(steps); float incy = dy / static_cast\u0026lt;float\u0026gt;(steps); for (int i = 0; i \u0026lt;= steps; ++i) // 由于第一个点画的是起点，所以从0开始 { image.set(x, y, color); x += incx; y += incy; } } 上述代码绘制结果：\n上面代码是$x$每次增量$1$，$y$每次增量$k$。发现$|dy| \u0026gt; |dx|$时会出现断裂情况， 当然我们依然可以像上面的交换并转置来解决这个问题。但是这里我们可以采用另外一种解决办法：我们向最大位移方向($|dx| \u0026gt; |dy|$ 则$x$，否则$y $)每次增量1。(除此之外，覆盖绘制不同颜色，左上角有点瑕疵，对绘制的像素坐标x,y四舍五入取整逼近最近像素点后就没有这个问题) 具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { int dx = x1 - x0; int dy = y1 - y0; int steps = std::max(std::abs(dx), std::abs(dy)); // 取最大位移方向：最大位移方向每次增加1 float x = x0; float y = y0; float incx = dx / static_cast\u0026lt;float\u0026gt;(steps); float incy = dy / static_cast\u0026lt;float\u0026gt;(steps); for (int i = 0; i \u0026lt;= steps; ++i) // 由于第一个点画的是起点，所以从0开始 { image.set(static_cast\u0026lt;int\u0026gt;(x+0.5), static_cast\u0026lt;int\u0026gt;(y+0.5), color); // +0.5取整比调用std::round效率高 x += incx; y += incy; } } 绘制效果：\n性能分析：\npass\n消除了循环内部分浮点数运算，性能略有提升。\nBresenham算法 中点的Bresenham算法 讨论一个简化的问题： 假设当前直线斜率$k \\in [0, 1]$, 最大位移方向为$x$(始终有$|dx| \u0026gt; |dy|$,如果不满足 代码实现上可交换$x$和$y$来满足此条件), 已知当前点$(x, y)$, 如何取下一个点？\n其实很明显，我们的下一个最佳逼近点只有两个候选点： $$ p_d = (x+1, y) \\ p_u = (x+1, y+1) $$\n那到底取哪一个点呢？\n哪个理论上离直线近就取哪一个。具体的我们可以这样评估：\n取两个候选点的中点$p_m = (x + 1, y + 0.5)$\n如果中点$p_m$在直线上方，则直线离$p_d$更近, 取$p_d $；\n如果中点$p_m$在直线下方， 则直线离$p_u$更近, 取$p_u$；\n如果在直线上，那可以随意取其一。\n判断在直线上方还是下方，我们可以使用直线的隐式方程： $$ f(x, y) = y - kx - b $$\n$f(x, y) \u0026gt; 0$: $(x, y)$在直线上方\n$f(x, y) \u0026lt; 0$: $ (x, y)$ 在直线下方\n$f(x, y) = 0$, $(x, y)$ 在直线上\n如果直线斜率$k \\in [-1,0]$, 那么候选点为：$p_u = (x+1, y )$, $p_d = (x+1, y - 1)$, 中点$p_m = (x+1, y-0.5)$在直线上方时取$p_d = (x+1, y - 1)$\n根据上方思路写出代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { bool steep = false; if (abs(x0 - x1) \u0026lt; abs(y0 - y1))// |dx| \u0026lt; |dy|， 转置 { steep = true; std::swap(x0, y0); std::swap(x1, y1); } if (x0 \u0026gt; x1) // 起点到终点为从左到右 { std::swap(x0, x1); std::swap(y0, y1); } // 以下逻辑为斜率k: 0 \u0026lt;= k \u0026lt;= 1 int dx = x1 - x0; int dy = y1 - y0; float k = static_cast\u0026lt;float\u0026gt;(dy) / dx; float b = y0 - k * x0; auto Fxy = [\u0026amp;](float x, float y) { return y - k * x - b; }; const float eps = 1e-4; for (int x = x0, y = y0; x \u0026lt;= x1; ++x) { if (steep) { image.set(y, x, color); // 转置回来 } else { image.set(x, y, color); } // 候选点:(x+1, yi),(x+1, y+1) // 两个候选点的中点(x + 1, y + 0.5)在直线下方，那么理论上直线离(x+1, y+1)更近 if (Fxy(x + 1, y + 0.5) \u0026lt; eps) { y = y + 1; } } } 代码分析：上方循环内计算Fxy为复杂的浮点数运算，而且判别比0大还是小还是浮点数比较。在性能上比不上DDA。\n实际上我们只需要知道判别式Fxy的符号， 如何来优化呢？\n当$k \\in [0, 1]$, 我们先看看判别项$d = f(x_m, y_m)$的规律： $$ d = f(x_m, y_m) = f(x_i + 1,y_i + 0.5) = y_i + 0.5 - k(x_i + 1) - b $$\n$d \u0026lt; 0$ , 取$(x_i + 1, y_i + 1)$, 那下一个判别项： $$ d = f(x_i + 2, y_i + 1.5) = y_i + 1.5 - k(x_i + 2) - b = y_i + 0.5 - k(x_i + 1) - b + 1 - k = d - k + 1 $$\n$d \u0026gt;= 0$, 取$(x_i + 1, y_i)$, 那下一个判别项： $$ d = f(x_i + 2, y_i + 0.5) = y_i + 0.5 - k(x_i + 2) - b = y_i + 0.5 - k(x_i + 1) - b - k = d - k \\ $$\n$d$的初始值： $$ d_0 = f(x_0 + 1, y_0 + 0.5) = y_0 + 0.5 - k(x_0 + 1) - b = y_0 - kx_0 - b + 0.5 - k = f(x_0, y_0) + 0.5-k = 0.5 - k $$ 上方只有$0.5$和$k$两个浮点数，$k = dy / dx$, 我们可以对浮点数的项同时扩大$2 * dx$倍： $$ d的初值:d_0 = dx - 2dy\\ d \u0026lt; 0: d = d + 2dx - 2dy\\ d \u0026gt;=0: d = d - 2dy $$\n$k \\in [-1, 0]$ 时：\n候选点为$(x+1, y), (x+1 y -1)$\n判别项: $$ d = f(x_m, y_m) = f(x_i+1, y_i-0.5) = y_i - 0.5 - k(x_i+1) - b $$\n$d \u0026gt; 0$时，取$(x + 1, y - 1)$, 那下一个判别项: $$ d = f(x_i + 2, y_i - 1.5) = d - k - 1 $$\n$d \u0026lt;= 0$时，取$(x + 1, y)$, 那下一判别项： $$ d = f(x_i + 2, y_i - 0.5) = d - k $$\n$d$的初值： $$ d_0 = f(x0 + 1, y - 0.5) = -0.5 - k $$\n有浮点数的项同时扩大$2 * dx$倍：\n$$ d的初值:d_0 = -dx - 2dy\\ d \u0026gt; 0: d = d - 2dy - 2dx\\ d \u0026lt;=0: d = d - 2dy $$\n那么优化后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { bool steep = false; if (abs(x0 - x1) \u0026lt; abs(y0 - y1))// |dx| \u0026lt; |dy|， 转置 { steep = true; std::swap(x0, y0); std::swap(x1, y1); } if (x0 \u0026gt; x1) // 起点到终点为从左到右 { std::swap(x0, x1); std::swap(y0, y1); } // 以下逻辑为斜率k: 0 \u0026lt;= k \u0026lt;= 1 int dx = x1 - x0; int dy = y1 - y0; const int twoDx = 2 * dx; const int twoDy = 2 * dy; int d = dx - twoDx; for (int x = x0, y = y0; x \u0026lt;= x1; ++x) { if (steep) { image.set(y, x, color); // 转置回来 } else { image.set(x, y, color); } if (d \u0026lt; 0) { y = y + 1; d = d + twoDx - twoDy; } else { d = d - twoDy; } } } 改进的Bresenham算法 不使用中点，而是直接使用交点：以直线与每个像素格子的交点 和 相交像素格子右下角点 的距离 作为判别项$d$。 综上：\n判别项$d$初值:$d_0 = 0$ 递推规律： $d = d + k$ 当 $d \u0026gt; 0.5$, 选择$p_u = (x + 1, y + 1)$， 同时$d = d - 1$ 当$d \u0026lt;= 0.5$, 选择$p_d = (x + 1, y)$ 发现出现$0.5$和$k$这两个浮点数, 对于$0.5$， 我们可以令$d$的初值：$d_0 = -0.5$ ，那么此时转化为$d$与0的比较\n此时$d = d + k$ 和$d = d - 1$依然存在浮点数计算（$d$初值-0.5，$k = dy/ dx$），我们可以让与浮点数相关项同时扩大$2*dx$倍用来消除浮点数, 那么就有：\n$d$的初值： $d_0 = -dx$ $d$的递推规律： $d = d + 2dy$ 当 $d \u0026gt; 0$, 选择$p_u = (x + 1, y + 1)$， 同时$d = d - 2dx$ 当$d \u0026lt;= 0$, 选择$p_d = (x + 1, y) $ 当$k \\in [-1,0]$时，递推判别项$d = d - k$, 然后将上述$(x + 1, y + 1)$ 替换成$(x + 1, y -1)$即可\n根据上述优化思路写出代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void line(int x0, int y0, int x1, int y1, TGAImage\u0026amp; image, const TGAColor\u0026amp; color) { bool steep = false; if (abs(x0 - x1) \u0026lt; abs(y0 - y1))// |dx| \u0026lt; |dy|， 转置 { steep = true; std::swap(x0, y0); std::swap(x1, y1); } if (x0 \u0026gt; x1) // 起点到终点为从左到右 { std::swap(x0, x1); std::swap(y0, y1); } // 以下逻辑为斜率k: 0 \u0026lt;= k \u0026lt;= 1 int dx = x1 - x0; int dy = y1 - y0; int d = -dx; const int twoDx = 2 * dx; const int twoDy = 2 * dy; for (int x = x0, y = y0; x \u0026lt;= x1; ++x) { if (steep) { image.set(y, x, color); // 转置回来 } else { image.set(x, y, color); } d = d + twoDy; if (d \u0026gt; 0) { y = y + 1; d = d - twoDx; } } } 参考资料： 中国mooc: 华中科技大学《计算机图形学》 ","date":"2022-09-18T22:19:00+08:00","permalink":"https://Enco-Lee.github.io/p/%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/","title":"画线算法"},{"content":" c++11开始引入了正则表达式库regex\n正则语法基础 .: 匹配任意单个字符，除了换行符\\n\n*: 匹配之前子表达式0次或多次\n?: 匹配之前表达式 0次或1次\n+: 匹配之前表达式1次或多次\n{m,n}: 显示指明匹配前面子表达式m到n次\n{m}: 显示指明匹配前面子表达式m次\n{m,}: 显示指明匹配前面子表达式至少m次\n()： 可用于创建子表达式，比如([a-z]+)\n[]: 用于匹配括号里面的内容，比如[a-z0-9]\n^:匹配输入字符串的开始位置，当出现在[]里面的开头时，表示除了[]里内容外都可以匹配，比如除了a,b,c外都可以匹配[^abc]\n$:匹配输入字符串的结束位置\n|：两项中选一个，比如([a-z]+)|([0-9]+)\n\\d: 匹配任意数字字符，等价[0-9]\n\\w:匹配字母、数字、下划线，等价于[A-Za-z0-9_]\n\\W:匹配非字母、数字、下划线，等价于 [^A-Za-z0-9_]\n\\： 标识转义用于匹配一个原义字符，或者标识一个特殊字符\nc++正则库的使用 regex库提供了3个正则匹配算法，通过这3个算法来学习c++正则库的基本使用\nregex_match 只关注有没有匹配成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 std::vector\u0026lt;std::string\u0026gt; fnames = { \u0026#34;foo.txt\u0026#34;, \u0026#34;bar.txt\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;a0.txt\u0026#34;, \u0026#34;AAA.txt\u0026#34; }; std::regex txt_regex(\u0026#34;[a-z]+\\\\.txt\u0026#34;); for_each(fnames.begin(), fnames.end(), [\u0026amp;](const auto\u0026amp; v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; is match:\u0026#34; \u0026lt;\u0026lt; std::boolalpha\u0026lt;\u0026lt;std::regex_match(v, txt_regex) \u0026lt;\u0026lt; std::endl; }); /* foo.txt is match:true bar.txt is match:true test is match:false a0.txt is match:false AAA.txt is match:false */ 匹配成功并取得匹配项上下文内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 std::vector\u0026lt;std::string\u0026gt; fnames = { \u0026#34;foo.txt\u0026#34;, \u0026#34;bar.txt\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;a0.txt\u0026#34;, \u0026#34;AAA.txt\u0026#34; }; std::regex base_regex(\u0026#34;([a-z]+)\\\\.([a-z]+)\u0026#34;); std::smatch base_match; for (const auto\u0026amp; name : fnames) { if (std::regex_match(name, base_match, base_regex)) { std::cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto\u0026amp; v : base_match) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl;// v type: std::ssub_match, string val = v.str(); } std::cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; std::endl; } } /* ---------- foo.txt foo txt ---------- ---------- bar.txt bar txt ---------- */ 可见，只要std::regex_match第二个参数传入std::smatch对象即可获取匹配项的上下文结果， std::smatch为可迭代对象，第一项为整个表达式匹配结果，后续项为子表达式匹配结果。\nregex_search 和regex_match的两种用法一样\nregex_search和regex_match的区别：\nregex_match只考虑完全匹配: 1 2 3 4 5 6 std::regex re(\u0026#34;Get|GetValue\u0026#34;); std::cmatch m; std::regex_search(\u0026#34;GetValue\u0026#34;, m, re); // returns true, and m[0] contains \u0026#34;Get\u0026#34; std::regex_match (\u0026#34;GetValue\u0026#34;, m, re); // returns true, and m[0] contains \u0026#34;GetValue\u0026#34; std::regex_search(\u0026#34;GetValues\u0026#34;, m, re); // returns true, and m[0] contains \u0026#34;Get\u0026#34; std::regex_match (\u0026#34;GetValues\u0026#34;, m, re); // returns false cmatch和smatch两者定义：\nstd::cmatch std::match_results\u0026lt;const char*\u0026gt; std::smatch std::match_results\u0026lt;std::string::const_iterator\u0026gt; 更多匹配项上下文信息可以通过std::smatch的成员函数来获取：\n匹配项前面内容：prefix()\n匹配项后面内容：suffix()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 std::string lines[] = { \u0026#34;Roses are #ff0000\u0026#34;, \u0026#34;violets are #0000ff\u0026#34;, \u0026#34;all of my base are belong to you\u0026#34; }; std::regex color_regex(\u0026#34;#([a-f0-9]{2})\u0026#34; \u0026#34;([a-f0-9]{2})\u0026#34; \u0026#34;([a-f0-9]{2})\u0026#34;); // show contents of marked subexpressions within each match std::smatch color_match; for (const auto\u0026amp; line : lines) { if (std::regex_search(line, color_match, color_regex)) { std::cout \u0026lt;\u0026lt; \u0026#34;matches for \u0026#39;\u0026#34; \u0026lt;\u0026lt; line \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Prefix: \u0026#39;\u0026#34; \u0026lt;\u0026lt; color_match.prefix() \u0026lt;\u0026lt; \u0026#34;\u0026#39;\\n\u0026#34;; for (size_t i = 0; i \u0026lt; color_match.size(); ++i) std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; color_match[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Suffix: \u0026#39;\u0026#34; \u0026lt;\u0026lt; color_match.suffix() \u0026lt;\u0026lt; \u0026#34;\\\u0026#39;\\n\\n\u0026#34;; } } /* matches for \u0026#39;Roses are #ff0000\u0026#39; Prefix: \u0026#39;Roses are \u0026#39; 0: #ff0000 1: ff 2: 00 3: 00 Suffix: \u0026#39;\u0026#39; matches for \u0026#39;violets are #0000ff\u0026#39; Prefix: \u0026#39;violets are \u0026#39; 0: #0000ff 1: 00 2: 00 3: ff Suffix: \u0026#39;\u0026#39; */ std::regex_search也支持直接传入c风格字符串进行匹配\nregex_replace 匹配替换后直接返回替换后的结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 std::string str{ \u0026#34;hello world\u0026#34; }; std::regex normal_regex(\u0026#34;world\u0026#34;); std::string ret = std::regex_replace(str, normal_regex, \u0026#34;regex\u0026#34;); std::cout \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; std::endl; std::string text = \u0026#34;Quick brown fox\u0026#34;; std::regex vowel_re(\u0026#34;a|e|i|o|u\u0026#34;); // write the results to an output iterator std::regex_replace(std::ostreambuf_iterator\u0026lt;char\u0026gt;(std::cout), text.begin(), text.end(), vowel_re, \u0026#34;*\u0026#34;); // construct a string holding the results std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; std::regex_replace(text, vowel_re, \u0026#34;[$\u0026amp;]\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; /* hello regex Q**ck br*wn f*x Q[u][i]ck br[o]wn f[o]x */ 替换项如果为$\u0026amp;则表示保持匹配结果内容，在$\u0026amp;两边加上字符很容易根据匹配结果 进行构造 替换项 ","date":"2022-09-15T14:57:00+08:00","permalink":"https://Enco-Lee.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/","title":"正则表达式总结"},{"content":"语法层面新特性 char8_ t 三路比较运算符：\u0026lt;=\u0026gt; lambda表达式使用[=]将无法隐式捕获this,需要[=, this]进行显示捕获 范围for循环可初始化： 1 2 3 4 5 std::vector\u0026lt;int\u0026gt; data{ 1, 2,3 }; for (auto vec = data; auto v : vec) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; } module(文件后缀为.ixx, import不要忘记加;):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // module_test.ixx export module hellocpp20; import \u0026lt;iostream\u0026gt;; using namespace std; export void hello() { cout \u0026lt;\u0026lt; \u0026#34;hello cpp20! \\n\u0026#34;; } // main.cpp import hellocpp20; int main() { hello(); return 0; } 标准库新特性 std::format:\n类似python的一种格式化, 注意在vs里面项目配置语言标准需要选/std:c++latest(听说是c++20+), 直接选``/std:c++20会报std中找不到format`错误\n1 2 3 int a = 10; int b = 10; std::cout \u0026lt;\u0026lt; std::format(\u0026#34;{} + {} = {}\\n\u0026#34;, a, b, a + b); 引入了协程：（留坑）\nranges库\n","date":"2022-09-15T12:09:00+08:00","permalink":"https://Enco-Lee.github.io/p/c-20%E6%96%B0%E7%89%B9%E6%80%A7/","title":"c++20新特性"},{"content":"语法层面新特性 变量模板 结合using的别名模板 泛型lambda（形参可用auto） 返回值类型推导： 1 2 3 int x = 1024; auto getX(){return x;} // return int auto getXX(){return (x);} // return int\u0026amp; 标准库新特性 std::make_unique构造unique_ptr ","date":"2022-09-13T23:39:00+08:00","permalink":"https://Enco-Lee.github.io/p/c-14%E6%96%B0%E7%89%B9%E6%80%A7/","title":"c++14新特性"},{"content":"语法层面新特性 结构化绑定声明： 1 2 3 4 5 6 std::map\u0026lt;int, int\u0026gt; mp; for(auto\u0026amp;\u0026amp; [k, v] : mp) { } std::tuple\u0026lt;int, double\u0026gt; tp(1, 2.0); auto[x, y] = tp; 标准库新特性 string_view: 当string使用char*进行构造时会重新分配内存然后拷贝char*指向的内容。 当内容只需要读取的时候完全不需要重新分配内存然后拷贝，只需要在原来的内容上建立一张视图，此时就可以使用string_view来做。 类型可擦除的std::any 多变类型std::variant，类似强化版的union 将tuple解包作为参数传入的std::apply: 1 2 3 4 5 auto print = [](int a, int b, int c) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; }; std::apply(print, std::tuple(1, 2, 3)); ","date":"2022-09-13T21:49:00+08:00","permalink":"https://Enco-Lee.github.io/p/c-17%E6%96%B0%E7%89%B9%E6%80%A7/","title":"c++17新特性"},{"content":"语法层面新特性 long long类型 char16_t,char32_t auto 和decltype nullptr 可变参模板参数 基于范围的for循环： for(auto x : vec){} 右值引用 移动拷贝构造和移动赋值构造 default,delete说明符 final ,override说明符 lambda表达式 委托构造和继承构造 list initialization: 使得所有类型都可以{}进行初始化，只需要重载形参为std::initializer_list的构造 constexpr：修饰后为常量表达式，编译期执行 使用using关键字声明类型别名 noexcept 说明符 和 noexcept operator 函数结合auto使用尾置返回值类型： 1 2 3 4 5 auto printInt(int x)-\u0026gt;int { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; return 0; } 标准库新特性 unorder_map和unordered_set以及它们multi版本 类型萃取支持（type_traits）： 借助模板和模板的偏特化来实现的 并发库的支持： thread,mutex, atomic, condition_variable等 智能指针： std::unique_ptr ,std::shared_ptr,std::weak_ptr 初始化列表：std::initializer_list 数组：array 元组：tuple 正则表达式：regex 可代替函数指针的std::function 用于包装函数对象的std::bind 单链表：std::forward_list 时间操作库： std::chrono 迭代器的改进，统一的迭代器获取：std::begin, std::end, std::next, std::prev ","date":"2022-09-13T21:39:00+08:00","permalink":"https://Enco-Lee.github.io/p/c-11%E6%96%B0%E7%89%B9%E6%80%A7/","title":"c++11新特性"},{"content":" 数组int a[] = {1, 2, 3,4}, a和\u0026amp;a, \u0026amp;a[0]的区别： a为数组名，值是指针常量， 类型是指向元素类型的常量指针, 只有两种场合下数组名并不表现为指针常量：一是sizeof操作符，另一个是取地址操作符\u0026amp; \u0026amp;a为数组的指针，int(*p)[4] = \u0026amp;a; // 指向4个int类型的数组指针 \u0026amp;a[0]为指向首元素的指针，int* p = \u0026amp;a[0]; 三者值相等，都等于首元素的地址 sizeof(a)等于整个数组所占字节，sizeof(\u0026amp;a) ==sizeof(\u0026amp;a[0]) 为指针所占字节大小（4或8字节） \u0026amp;a + 1偏移整个数组所占字节大小，a + 1 和\u0026amp;a[0] + 1偏移元素所占字节大小 char[] str = \u0026quot;hello\u0026quot;;和char* pstr = \u0026quot;hello\u0026quot;;的区别： 第一个为字符串数组，第二个为字符串常量 sizoef(str) = strlen(str)+1，char数组后面会自动填充字符串结束符\\0, sizeof(pstr)为指针大小 str[1] = 'a'修改是安全的，而对*(ptr+1) = 'a'修改是不安全的； const: 在*右边 则修饰 指针它本身，否则修饰它指向的内容 修饰左值引用可以引用右值 修饰成员函数可构成重载 对象指针为空指针可以调用成员函数，原因是函数地址在编译期已经确定了 explicit关键字是修饰构造函数的，表明不可以隐式转换成该类型对象 有int和int*形参两个构成重载的函数，当传入NULL时将调用int形参版本的函数，原因是c++的NULL为0的宏。c++11引入nullptr可以解决这种调用不符本意的问题。 ","date":"2022-09-11T23:51:00+08:00","permalink":"https://Enco-Lee.github.io/p/cpp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"cpp基础知识"},{"content":"\n疑问 突然写了上方这样的代码，然后居然没有报错。让我产生了疑问： private成员不是不允许外部访问吗？这么为什么这里可以直接访问？难道外部是指非本身类内？\n解答 封装是编译期的概念，是针对类型而非对象的，在类的成员函数中是可以访问同类型实例对象的私有成员变量的。 ref ","date":"2022-09-08T23:06:00+08:00","permalink":"https://Enco-Lee.github.io/p/%E5%AF%B9%E4%BA%8Ec-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E8%AF%AF%E8%A7%A3/","title":"对于c++面向对象访问权限的误解"},{"content":"vector push_back 和emplace_back: 总结：\nemplace_back支持直接传入对象初始化参数列表（由于c++11可变模版参数使得可以传入很多参数） 并会在vector内存中原地构造， push_back支持传入一个对象参数， 但是表现是先构造一个临时对象然后执行移动构造（下方test4中注释为运行结果）。 其他用法两者没有区别 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Value { public: Value(int x, int y = 2) :_x(x), _y(y) { std::cout \u0026lt;\u0026lt; \u0026#34;Value()\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Value() { std::cout \u0026lt;\u0026lt; \u0026#34;~Value()\u0026#34; \u0026lt;\u0026lt; std::endl; } Value(const Value\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;Value(const Value\u0026amp;)\u0026#34; \u0026lt;\u0026lt; std::endl; } Value(Value\u0026amp;\u0026amp; v) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;Value(Value\u0026amp;\u0026amp;)\u0026#34; \u0026lt;\u0026lt; std::endl; } Value\u0026amp; operator=(const Value\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;operator=(const Value\u0026amp;)\u0026#34; \u0026lt;\u0026lt; std::endl; } Value\u0026amp; operator=(Value\u0026amp;\u0026amp; v) noexcept { std::cout \u0026lt;\u0026lt; \u0026#34;operator=(Value\u0026amp;\u0026amp;)\u0026#34; \u0026lt;\u0026lt; std::endl; } int getX() const { return _x; } int getY() const { return _y; } private: int _x; int _y; }; void test1() { std::vector\u0026lt;Value\u0026gt; vec; vec.reserve(5); Value a(0, 0); std::cout \u0026lt;\u0026lt; \u0026#34;## push_back val\u0026#34; \u0026lt;\u0026lt; std::endl; vec.push_back(a); // Value(const Value\u0026amp;) std::cout \u0026lt;\u0026lt; \u0026#34;## emplace_back val\u0026#34; \u0026lt;\u0026lt; std::endl; vec.emplace_back(a); // Value(const Value\u0026amp;) std::cout \u0026lt;\u0026lt; std::string(100, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; std::endl; } void test2() { std::vector\u0026lt;Value\u0026gt; vec; vec.reserve(5); Value a(3, 4); std::cout \u0026lt;\u0026lt; \u0026#34;## push_back val\u0026#34; \u0026lt;\u0026lt; std::endl; vec.push_back(std::move(a)); // Value(Value\u0026amp;\u0026amp;) std::cout \u0026lt;\u0026lt; \u0026#34;## emplace_back val\u0026#34; \u0026lt;\u0026lt; std::endl; // 注意这里只是为了测试才再对同一对象std::move， // 实际上如果移动构造出现资源转移等指针操作，再次std::move同一对象很危险 vec.emplace_back(std::move(a)); // Value(Value\u0026amp;\u0026amp;) std::cout \u0026lt;\u0026lt; std::string(100, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; std::endl; } void test3() { std::vector\u0026lt;Value\u0026gt; vec; vec.reserve(5); Value a(0, 0); std::cout \u0026lt;\u0026lt; \u0026#34;## push_back val\u0026#34; \u0026lt;\u0026lt; std::endl; vec.push_back(Value(1)); // Value() Value(Value\u0026amp;\u0026amp;) std::cout \u0026lt;\u0026lt; \u0026#34;## emplace_back val\u0026#34; \u0026lt;\u0026lt; std::endl; vec.emplace_back(Value(1)); // Value() Value(Value\u0026amp;\u0026amp;) std::cout \u0026lt;\u0026lt; std::string(100, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; std::endl; } void test4() { std::vector\u0026lt;Value\u0026gt; vec; vec.reserve(5); std::cout \u0026lt;\u0026lt; \u0026#34;## push_back val\u0026#34; \u0026lt;\u0026lt; std::endl; //vec.push_back(1, 2); // error vec.push_back(1); // Value() Value(Value\u0026amp;\u0026amp;) std::cout \u0026lt;\u0026lt; \u0026#34;## emplace_back val\u0026#34; \u0026lt;\u0026lt; std::endl; vec.emplace_back(1, 2); // Value() std::cout \u0026lt;\u0026lt; std::string(100, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; std::endl; } ","date":"2022-09-08T22:57:00+08:00","permalink":"https://Enco-Lee.github.io/p/vector%E4%B8%ADpush_back%E5%92%8Cemplace_back%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/","title":"vector中push_back和emplace_back有啥区别？"},{"content":"移动语义和完美转发 左值：表达式结束后依然存在的持久化对象，注意：具名右值引用是左值：int\u0026amp;\u0026amp; val = 1024; // val为左值\n右值：表达式结束后将不存在的临时对象\n右值引用：用于延长右值的生命周期\nstd::move(v): 强制将左值转换为右值；\n本质仅仅是强制类型转换：static_cast\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(t)，使得可匹配右值形参函数； 只有结合移动构造函数或移动赋值操作符才能起到减少不必要拷贝的意义 基本类型执行std::move并不会将原来变量内容改变,只是执行简单的拷贝，比如int x = 1024; int y = std::move(x); //x依然为1024， y:1024。 const左值引用可以引用右值(const 引用可以绑定非左值)： const int \u0026amp; a = std::move(1) std::forward\u0026lt;T\u0026gt;(v) ：保持v原本的类型进行传递\n一般就用于模板中，功能表现上等价于std::static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;, （T\u0026amp;\u0026amp;基于引用折叠规则，也称万能引用）\n普通的传参转发不管传入左值还是右值，转发时都表现为左值，此时就有了完美转发的用武之地了\n引用折叠规则（这个规则只会出现在模板中）： 只有两个都是右值引用互相折叠才能折叠为右值引用（\u0026amp;\u0026amp; \u0026amp;\u0026amp; =\u0026gt; \u0026amp;\u0026amp;），否则折叠都是左值引用 (\u0026amp;\u0026amp; \u0026amp;=\u0026gt;\u0026amp;, \u0026amp; \u0026amp;\u0026amp;=\u0026gt;\u0026amp;, \u0026amp; \u0026amp;=\u0026gt; \u0026amp;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void ref(int\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;lvalue ref \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; } void ref(int\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;rvalue ref \u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; } void pass(int\u0026amp; v) { ref(v); // 调用ref(int\u0026amp;) ref(std::move(v));// 调用ref(int\u0026amp;\u0026amp;) // 下面的这两种写法在这里没啥意义，所以std::forward多用于函数模板 ref(std::forward\u0026lt;int\u0026amp;\u0026gt;(v)); // 调用ref(int\u0026amp;) ref(static_cast\u0026lt;int\u0026amp;\u0026gt;(v)); // 调用ref(int\u0026amp;) // 用于体会std::forward功能表现 ref(std::forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(v)); // 调用ref(int\u0026amp;\u0026amp;) ref(static_cast\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(v)); // 调用ref(int\u0026amp;\u0026amp;) } void pass(int\u0026amp;\u0026amp; v) { ref(v); // 转发调用的是ref(int\u0026amp;)!!! // 下面的调用看起来怪怪的，但是只有这样才能保持v的原来类型 ref(std::move(v));// 调用ref(int\u0026amp;\u0026amp;) ref(std::forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(v)); // 按右值进行转发, 调用ref(int\u0026amp;\u0026amp;) ref(static_cast\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(v)); // 调用ref(int\u0026amp;\u0026amp;) } // 调用 pass(1024); int v = 1024; pass(v); 上面的两个pass函数，不管去掉哪一个都会导致其中一种类型的传参失败，但是这样写起来太繁琐了，使用模板函数和万能引用T\u0026amp;\u0026amp;可以解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename T\u0026gt; void pass(T\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34; normal param passing: \u0026#34;; ref(v); std::cout \u0026lt;\u0026lt; \u0026#34; std::move param passing: \u0026#34;; ref(std::move(v)); std::cout \u0026lt;\u0026lt; \u0026#34; std::forward param passing: \u0026#34;; ref(std::forward\u0026lt;T\u0026gt;(v)); std::cout \u0026lt;\u0026lt; \u0026#34; static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt; param passing: \u0026#34;; ref(static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(v)); } // 调用 pass(1024); // pass(int\u0026amp;\u0026amp;) int v = 1024; pass(v); // pass(int\u0026amp;) ","date":"2022-09-06T23:50:00+08:00","permalink":"https://Enco-Lee.github.io/p/move-and-forward/","title":"move and forward"},{"content":" 不可真virtuel的函数可以借助可真virtuel的成员函数达到伪virtual。比如构造函数和非成员函数的\u0026quot;虚\u0026quot;化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Component { public: virtual std::ostream\u0026amp; print(std::ostream\u0026amp; out) const = 0; }; class AComponent :public Component { public: virtual std::ostream\u0026amp; print(std::ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;A\u0026#34;; return out; } }; class BComponent :public Component { public: virtual std::ostream\u0026amp; print(std::ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;B\u0026#34;; return out; } }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, Component\u0026amp; c) { return c.print(out); } // 使用 AComponent a; BComponent b; std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 当没有namespace限定作用域时，类中friend函数为全局作用域，而类中static作用域限定在类空间\n多用namespace, 可以避免命名冲突，同时某些时候可以简化书写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace PrintingStuff { class Printer { private: Printer() {}; //... public: void doX() {}; void doY() {}; //... friend Printer\u0026amp; thePrinter(); }; Printer\u0026amp; thePrinter() { static Printer printer; return printer; } } // 使用 using PrintingStuff::thePrinter; thePrinter().doX(); thePrinter().doY(); 不要将含local static对象的非成员函数inline化：由于inline函数复制可能导致产生多个static对象副本\n避免具体类继承具体类\npass\n实现String类：引用计数，写时复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 // version 1 // my_string.h #pragma once #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; namespace MyStr { class String { public: String(const char* str=\u0026#34;\u0026#34;); String(const String\u0026amp; s); String\u0026amp; operator=(const String\u0026amp; s); ~String(); const char\u0026amp; operator[](size_t index) const; char\u0026amp; operator[](size_t index); // 重载实现写时复制 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, String\u0026amp; s); private: struct StringValue { char* m_data; int m_refCount; StringValue(const char* str) :m_refCount(1) { size_t len = std::strlen(str); m_data = new char[len + 1]; std::strncpy(m_data, str, len); m_data[len] = \u0026#39;\\0\u0026#39;; }; ~StringValue() { delete[] m_data; } }; StringValue* m_pValue; }; } // my_string.cpp #include \u0026#34;my_string.h\u0026#34; namespace MyStr { String::String(const char* str):m_pValue(new StringValue(str)) { } String::String(const String\u0026amp; s) { m_pValue = s.m_pValue; ++m_pValue-\u0026gt;m_refCount; } String\u0026amp; String::operator=(const String\u0026amp; s) { if (m_pValue == s.m_pValue) { return *this; } if (--m_pValue-\u0026gt;m_refCount == 0) { delete m_pValue; } m_pValue = s.m_pValue; ++m_pValue-\u0026gt;m_refCount; return *this; } String::~String() { if (--m_pValue-\u0026gt;m_refCount == 0) { delete m_pValue; } } const char\u0026amp; String::operator[](size_t index) const { return m_pValue-\u0026gt;m_data[index]; } char\u0026amp; String::operator[](size_t index) { if (m_pValue-\u0026gt;m_refCount \u0026gt; 1) { --m_pValue-\u0026gt;m_refCount; m_pValue = new StringValue(m_pValue-\u0026gt;m_data); } return m_pValue-\u0026gt;m_data[index]; } std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, String\u0026amp; s) { out \u0026lt;\u0026lt; s.m_pValue-\u0026gt;m_data; return out; } } ","date":"2022-08-31T00:00:00Z","permalink":"https://Enco-Lee.github.io/p/more-effective-c-%E6%8A%80%E6%9C%AF%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/","title":"《More Effective C++》技术章节笔记"},{"content":"thread 基础概念：\n并发：一个处理器在一定时间间隔(时间片)内轮流执行任务。 多任务是抢占资源的。\n并行：多个处理器同一时间点上同时执行任务。 不抢占资源。\n临界资源： 在一段时间内仅允许一个进程访问的资源。比如打印机，各个进程采用互斥的方式实现对资源的共享，\n临界区： 每个进程访问临界资源的那段代码和共享变量有关的程序段。\n并发的实现方式 通过多个进程实现并发 通过创建多个线程实现并发 进程间通信 同一电脑： 管道，共享内存，文件， 消息队列 不同电脑： socket通信 线程间通信 共享内存，比如使用全局变量 共享数据分析： 只读数据：它是安全的稳定的，直接读即可； 有读有写：不安全，最简单处理：读写互斥 死锁 只有至少有两把锁才可能出现死锁\n描述：1持有A，想要B；2持有B，想要A。导致1,2无法继续执行的僵持状态\n互斥量：用于多线程编程种保护共享数据\n解决死锁：\n多个互斥量，保存相同的上锁顺序\n当多个互斥量时，使用std::lock()进行上锁，这个接口使得上锁顺序无关：std::lock(mtx1, mtx2), 还是记住需要手动解锁， 可配合std::lock_guard避免手动解锁：\n1 2 3 std::lock(m1, m2); // 一次性锁多个 std::lock_guard\u0026lt;std::mutex\u0026gt;(m1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt;(m2, std::adopt_lock); API 1 2 3 thread t(func); // 传入一个可调用对象: 函数对象，lambda函数， 仿函数等 t.join(); // 阻塞主线程 等子线程执行完后与主线程汇合 t.deatch(); // 分离，子线程执行不可控，子线程和主线程各自执行各的，主线程不需要等待， 子线程执行完毕有接管他的运行时库进行清理 一般不需要关心或者控制子线程的执行时就调用detach 使用detach时，需要避免线程入口函数的传参隐式类型的转换，防止局部对象失效， 可以显示构造一个临时对象传入避免不安全使用对象 尽可能不使用detach 明确往线程对象入口函数参数指定需要传入真引用则必须使用std::ref，否则都是默认拷贝，但是传真引用只有使用join才是安全的 lock_guard std::lock_gurad\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock), std::adopt_lock适应之前mtx已经了lock，从而不再lock unique_lock 可以完全取代lock_guard, 而且更灵活，但是占有更多空间，相比std::adopt_lock还有其他参数\nstd::try_to_lock:尝试用mutex的lock()去锁定mutex， 如果没有锁成功也立即返回不会阻塞，但需要注意std::try_to_lock之前不能手动调用mutex的lock()否则会卡死。unique_lock对象成员函数owns_lock() 可以 判断有没有拿到锁\nstd::defer_lock: 初始化一个没有加锁的mutex， 使用前提也是不能对传入的mutex对象lock()，否则报异常。\n成员函数：\nlock() unlock()：虽然会自动加锁解锁，但是提供lock和unlock是为了临时解锁处理一些非共享代码 try_lock(): return true or false release():释放管理的mutex的所有权，返回之前管理的mutex对象的指针，之后需要我们自己负责mutex对象的unlock unique_lock对象所有权转移方法：使用std::move； 通过一个函数作为临时对象返回；\n条件变量 std::condition_variable:需要结合互斥量进行使用 wait(): 第一个参数为互斥量对象\n没有第二个参数，则解锁互斥量，当前线程执行阻塞到本行，直到其他线程notify_one；\n如果第二个参数为lambda，若lambda返回true则wait直接返回继续执行，否则解锁互斥量，阻塞到本行，直到被notify_one\n当被唤醒时： 重新尝试对互斥量加锁，直到加锁成功后继续往下执行\n虚假唤醒：即使没有notify该线程也有概率会唤醒，处理：wait中要第二个参数（lambda）并正确判断要处理的共享数据是否存在\n有可能出现一个线程还没走到wait时，notify消息就发送了，此时后面就可能导致盲目等待了，所以执行wait需要判断一些条件\nnotify_one():尝试把wait的线程唤醒\nfuture vaild(): 判断值是否有效\nshare(): 用于future对象构造shared_future，比如std::shared_future sf(f.share());\nfuture_status\n1 pass shared_future: 用于多个线程获取future数据，由于普通future对象只支持get一次，std::shared_future\u0026lt;int\u0026gt; sf = std::thread([]{return 1;});\natomic 原子操作概念：不可分割的操作，要么完成要么未完成， 不可能出现中间状态。在多线程种不会被打断的程序执行片段。 效率上比互斥量更高。适用于一个变量而不是一个代码段。能用原子操作就不用互斥量；一般针对++, --, +=, -=操作符，其他的不一定支持原子操作，比如x = x + 1不支持原子操作。 load()原子方式读取值，没有拷贝构造和赋值操作符， 可以这样进行复制：std::atomic\u0026lt;int\u0026gt; m2(m1.load()); store(v)原子方式写入值，std::atomic\u0026lt;int\u0026gt;m1 = 0; m1.store(1); async 用于创建异步任务\n第一个标志参数指定std::launch::async：强制异步任务在新线程中执行， 当future对象调用get或者wait时执行\n当第一个标志参数使用std::launch::deferred：不会创建新线程，会到主线程中执行，如果future没有get或者wait将不执行\n当第一个标志参数为std::launch::async | std::launch::deferred ,由系统评估选择其一执行，当第一个参数不传入标志参数时，默认就是这种参数。\n当系统资源紧张的时候，使用std::thread可能创建线程失败，出现程序奔溃\n相比std::thread,std::async获取入口参数返回值更简单，由于可以默认由系统决定是否创建新线程，在资源紧张情况下，这种方式也更安全\n经验： 一个程序不宜超过100-200个线程\n当为默认标志参数时，系统采用的策略（std::launch::async ，std::launch::deferred）确定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 std::future\u0026lt;int\u0026gt; ret = std::async([]() { std::this_thread::sleep_for(std::chrono::milliseconds(5000)); std::cout \u0026lt;\u0026lt;\u0026#34; async this_thread id \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; std::endl; return 1024;}); std::future_status status = ret.wait_for(std::chrono::seconds(0)); if (status == std::future_status::deferred) { // 延迟执行，由于资源紧张没有创建新线程，将在主线程中执行 std::cout \u0026lt;\u0026lt; \u0026#34;deferred\u0026#34; \u0026lt;\u0026lt; std::endl; //这个时候在主线程中执行 std::cout \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; std::endl; } else // 创建了新线程执行 { if (status == std::future_status::ready) { // 线程执行完毕，成功返回 std::cout \u0026lt;\u0026lt; \u0026#34;ready\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; std::endl; } else if (status == std::future_status::timeout) { // 线程还在执行 std::cout \u0026lt;\u0026lt; \u0026#34;timeout\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; std::endl; } } windows下的临界区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;vector\u0026gt; class A { public: A() { InitializeCriticalSection(\u0026amp;_wCS); } CRITICAL_SECTION _wCS; // 相当于std::mutex void pushValue(int v) { EnterCriticalSection(\u0026amp;_wCS); // 相当于lock //EnterCriticalSection(\u0026amp;_wCS); vec.push_back(v); //LeaveCriticalSection(\u0026amp;_wCS); LeaveCriticalSection(\u0026amp;_wCS); // unlock } private: std::vector\u0026lt;int\u0026gt; vec; }; class WindowsLockGuard { public: WindowsLockGuard(CRITICAL_SECTION* wcs):_pCS(wcs){ EnterCriticalSection(_pCS); } ~WindowsLockGuard() { LeaveCriticalSection(_pCS); } private: CRITICAL_SECTION* _pCS; }; windows中允许在同一个线程中（不同线程会卡住等待）进入同一个临界区多次, c++11不允许在同一线程中lock普通互斥量多次，否则报异常； recursive_mutex 允许在同一线程中同一个递归互斥量多次lock 一般使用它是代码设计的不太好，使用后需要考虑是否有优化空间，使得只lock一次 带超时的互斥量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 std::timed_mutex t_mtx; std::recursive_timed_mutex rt_mtx; if (t_mtx.try_lock_for(std::chrono::seconds(2))) // 尝试等待2s 获取锁 { // 保护内容 t_mtx.unlock(); } else // 普通mutex没拿到锁会阻塞，没法走下这里 { // 没有拿到锁 // 可以处理不需要保护内容 } // 直到某个时间点获取锁 if (t_mtx.try_lock_until(std::chrono::steady_clock::now() + std::chrono::milliseconds(1000))) { } else { } ","date":"2022-08-31T00:00:00Z","permalink":"https://Enco-Lee.github.io/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/","title":"c++多线程总结"},{"content":"一个简单的lua 解释器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // simpleLuaInterpreter.cpp : 此文件包含 \u0026#34;main\u0026#34; 函数。程序执行将在此处开始并结束。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #include \u0026#34;lua.h\u0026#34; // 高度抽象化的基础API #include \u0026#34;lauxlib.h\u0026#34; // 包含辅助库函数声明，函数以luaL_开头 #include \u0026#34;lualib.h\u0026#34; // 包含打开库的函数的声明 #ifndef __cpluscplus } #endif // !__cpluscplus // 辅助库没有方式去解释lua,只能通过lua.h中的基础API /* Lua库根本没有定义C的全局变量,它将其所有状态保持在动态结构中。 Lua内部的所有函数都会收到指向该结构的指针。 */ // #include \u0026#34;lua.hpp\u0026#34; //可代替extern \u0026#34;C\u0026#34;{#include \u0026#34;lua.h\u0026#34;} int main() { char buff[256]; int error; lua_State* L = luaL_newstate(); // 创建一个新状态但是它的环境中没有预先定义任何函数 luaL_openlibs(L); // 打开所有标准库 // luaL_loadstring:编译用户输入，如果不出错，return0并将结果压入stack // lua_pcall 不出错return 0 // 两个函数出错会将错误信息压入stack while (fgets(buff, sizeof(buff), stdin) != NULL) { error = luaL_loadstring(L, buff) || lua_pcall(L, 0, 0, 0); if (error) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, lua_tostring(L, -1)); lua_pop(L, 1); } lua_close(L); } std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;; return 0; } lua 和 C 组件的通信 lua 和 C 主要组件的通信 是通过强大的虚栈（virtual stack）\n虚栈压入元素 1 2 3 4 5 6 void lua_pushnil (lua_State *L); void lua_pushboolean (lua_State *L, int bool); void lua_pushnumber (lua_State *L, lua_Number n); void lua_pushinteger (lua_State *L, lua_Integer n); void lua_pushlstring (lua_State *L, const char *s, size_t len); void lua_pushstring (lua_State *L, const char *s); 向栈中压入元素前要保证stack中至少有20个空位（slots）,在lua.h中定义了这个常量宏：LUA_MINSTACK； 检查虚栈空间是否足够的函数：\nint lua_checkstack (lua_State *L, int sz); void luaL_checkstack (lua_State *L, int sz, const char *msg); 参数sz是需要检查的slots数量，第二个函数使得可以返回一个自定义的出错信息而不是错误码；\n虚栈提取元素 index可正可负，第一个压入元素（栈底）的index=1,最后压入元素（栈顶）的index=-1；\n获取栈中元素个数：size_t n = lua_gettop(L)；\n检查获取元素的类型 可以使用：int lua_is* (lua_State *L, int index);,*换成想要检查的lua数据类型 ，比如lua_isnil,lua_isstring。lua_isnumber和lua_isstring比较特殊，两者并不能确定元素类型而是是检查index位置上的元素是否可以转换为该类型。除此之外可以使用lua_type(L,index)获取到元素类型，返回值是lua.h中定义的宏，比如：LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER, LUA_TSTRING。\n获取元素的函数：\nint lua_toboolean (lua_State *L, int index); // nil和false时为0，其他类型元素为1 const char *lua_tolstring (lua_State *L, int index,size_t *len); // 同时获取字符串长度，存到len中 const char *lua_tostring (lua_State *L, int index); // 不需要长度信息可使用这个函数获取字符串 lua_State *lua_tothread (lua_State *L, int index); // index处获取一个线程，失败时返回NULL lua_Number lua_tonumber (lua_State *L, int index); lua_Integer lua_tointeger (lua_State *L, int index); 其他虚栈操作 int lua_gettop (lua_State *L); // 获取栈元素个数，也是栈顶的的正index void lua_settop (lua_State *L, int index); // 当index大于现在栈元素个数时补nil,小于时丢弃多的，置空：lua_settop(L,0) void lua_pushvalue (lua_State *L, int index); // 拷贝一个index处的元素压入栈中 void lua_rotate (lua_State *L, int index, int n); // 从index处到栈顶，旋转n个位置 void lua_remove (lua_State *L, int index); // 移除index处元素 void lua_insert (lua_State *L, int index); // 将index处元素放到栈顶 void lua_replace (lua_State *L, int index); // 弹出栈顶元素赋值到index处 void lua_copy (lua_State *L, int fromidx, int toidx); lua_settop (lua_State *L, int index)的index也可以是负下标，由此定义了一个弹出n个元素的宏#define lua_pop(L,n) lua_settop(L,-(n)-1)比如弹出3个元素，lua_pop(L,3) =\u0026gt;lua_settop(L,-4),栈顶-1设置成-4，由-1 to -4 弹出了3个元素；\nremove宏可通过rotate和pop来实现：#define lua_remove(L,idx) (lua_rotate(L, (idx), -1), lua_pop(L, 1))\ninsert 的宏实现#define lua_insert(L,idx) lua_rotate(L, (idx), 1)\nlua_rotate 源码： 1 2 3 4 5 6 7 8 9 10 11 12 LUA_API void lua_rotate (lua_State *L, int idx, int n) { StkId p, t, m; lua_lock(L); t = L-\u0026gt;top - 1; /* end of stack segment being rotated */ p = index2stack(L, idx); /* start of segment */ api_check(L, (n \u0026gt;= 0 ? n : -n) \u0026lt;= (t - p + 1), \u0026#34;invalid \u0026#39;n\u0026#39;\u0026#34;); m = (n \u0026gt;= 0 ? t - n : p - n - 1); /* end of prefix */ reverse(L, p, m); /* reverse the prefix with length \u0026#39;n\u0026#39; */ reverse(L, m + 1, t); /* reverse the suffix */ reverse(L, p, t); /* reverse the entire segment */ lua_unlock(L); } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; { #include \u0026#34;lua.h\u0026#34; // 高度抽象化的基础API #include \u0026#34;lauxlib.h\u0026#34; // 包含辅助库函数声明，函数以luaL_开头 #include \u0026#34;lualib.h\u0026#34; // 包含打开库的函数的声明 } static void dumpStack(lua_State* L) { size_t n = lua_gettop(L); for (size_t i = 1; i \u0026lt;= n; ++i) { int t = lua_type(L, i); switch (t) { case LUA_TBOOLEAN: { std::cout \u0026lt;\u0026lt; (lua_toboolean(L, i) ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) \u0026lt;\u0026lt; std::endl; break; } case LUA_TSTRING: { std::cout \u0026lt;\u0026lt; (lua_tostring(L, i)) \u0026lt;\u0026lt; std::endl; break; } case LUA_TNUMBER: { if (lua_isinteger(L, i)) { std::cout \u0026lt;\u0026lt; lua_tointeger(L, i) \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; lua_tonumber(L, i) \u0026lt;\u0026lt; std::endl; } break; } default: { std::cout \u0026lt;\u0026lt; lua_typename(L, i) \u0026lt;\u0026lt; std::endl; break; } } } } class SmartLuaState { public: SmartLuaState(lua_State* LL=nullptr):L(LL) { } ~SmartLuaState() { if (L != nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;close lua_State\u0026#34; \u0026lt;\u0026lt; std::endl; lua_close(L); } } void pushnil() { lua_pushnil(L); } void pushboolean(int n) { lua_pushboolean(L, n); } void pushstring(const char *s) { lua_pushstring(L, s); } lua_State* get_state() { return L; } void dumpStack(); void rotate(int index,int n) { lua_rotate(L, index, n); } void insert(int index) { lua_insert(L, index); } private: lua_State* L; }; void SmartLuaState:: dumpStack() { std::cout \u0026lt;\u0026lt; \u0026#34;values of stack\u0026#34; \u0026lt;\u0026lt; std::endl; size_t n = lua_gettop(L); for (size_t i = 1; i \u0026lt;= n; ++i) { int t = lua_type(L, i); switch (t) { case LUA_TBOOLEAN: { std::cout \u0026lt;\u0026lt; (lua_toboolean(L, i) ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) \u0026lt;\u0026lt; std::endl; break; } case LUA_TSTRING: { std::cout \u0026lt;\u0026lt; (lua_tostring(L, i)) \u0026lt;\u0026lt; std::endl; break; } case LUA_TNUMBER: { if (lua_isinteger(L, i)) { std::cout \u0026lt;\u0026lt; lua_tointeger(L, i) \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; lua_tonumber(L, i) \u0026lt;\u0026lt; std::endl; } break; } default: { std::cout \u0026lt;\u0026lt; lua_typename(L, i) \u0026lt;\u0026lt; std::endl; break; } } } } static void test1() { SmartLuaState smt = SmartLuaState(luaL_newstate()); lua_State* L = smt.get_state(); lua_pushboolean(L, 1); lua_pushnumber(L, 10); lua_pushnil(L); lua_pushstring(L, \u0026#34;hello\u0026#34;); dumpStack(L); std::cout \u0026lt;\u0026lt; \u0026#34;--- hello lua -- \u0026#34; \u0026lt;\u0026lt; std::endl; smt.dumpStack(); } static void test2() { SmartLuaState state = SmartLuaState(luaL_newstate()); state.pushstring(\u0026#34;a\u0026#34;); state.pushstring(\u0026#34;b\u0026#34;); state.pushstring(\u0026#34;c\u0026#34;); state.pushstring(\u0026#34;d\u0026#34;); state.dumpStack(); state.rotate(2, 4); //state.insert(2); state.dumpStack(); //state.rotate(2, -1); } int main() { // test1(); test2(); return 0; } ","date":"2021-07-25T00:00:00Z","image":"https://Enco-Lee.github.io/p/lua-c-api/capi-01_huca6d7e28af0b1415d7250274d96385f1_25992_120x120_fill_box_smart1_3.png","permalink":"https://Enco-Lee.github.io/p/lua-c-api/","title":"lua-C API"},{"content":" modules and packages , lua 5.1 后 提供了一系列模块和包策略\npackage 是 modules 的集合 加载使用模块 1 2 local m = require \u0026#34;math\u0026#34; print(m.sin(3.14)) -- 0.0015926529164868 require 的参数和返回值 参数 require只需要传入一个参数 1 2 3 4 5 6 7 8 math = require(\u0026#34;math\u0026#34;) -- 只有当这个参数是纯字符串时，括号才是可选的 string = require \u0026#34;string\u0026#34; -- 解释器是通过式预加载的方式载入模块，所以我们可以修改预加载好的模块标识而不影响原来的库 math.sin = print math.sin(1,2,3) -- 1 2 3 cos = require \u0026#34;math\u0026#34;.cos -- 也可以加载特定的函数，这种参数不能加() print(cos(3.14)) -- -0.99999873172754 返回值 如果加载成功，模块有返回值，就是模块返回值的类型，如果没有返回值，返回值为boolean类型; 模块加载失败会报错 ; ref; 其他 一旦某个模块已经加载成功，其他需要用这个模块的调用都只需返回这个模块，而不需执行其他代码（比如查找模块等） 加载操作时查找lua模块的路径存在package.path中,加入 查找路径 示例： 1 package.path = package.path .. \u0026#39;;D:/lua_note/chapter17/?.lua\u0026#39; -- 注意添加路径前需要加\u0026#34;;\u0026#34; 如果在lua文件中没有找到这个模块，会去搜索C的模块，搜索路径为：package.cpath 为了避免相同模块被加载两次，可以这样设置： 1 package.loaded.modname = nil 编写lua模块 简单示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 -- D:/lua_note/chapter17/complex.lua:一个简单的复数模块 local M = {} --package.loaded[...] = M -- 前面放进去后面就不用返回值 -- 创建一个新的复数:z = ar+bi -- 实部：[r] = r,虚部：[i] = i local function new(r,i) return {r=r,i=i} end M.new = new --将new函数加入模块 -- 纯虚数 z = i M.i = new(0,1) -- 复数相加 function M.add(c1,c2) return new(c1.r+c2.r,c1.i+c2.i) end -- 复数相减 function M.sub(c1,c2) return new(c1.r-c2.r,c1.i-c2.i) end -- 复数相乘 function M.mul(c1,c2) return new(c1.r*c2.r-c1.i*c2.i,c1.r*c2.r+c1.i*c2.i) end local function inv(c) local n = c.r^2 + c.i^2 return new(c.r/n,-c.i/n) end -- 复数相除 function M.div(c1,c2) return M.mul(c1,inv(c2)) end function M.tostring(c) return string.format(\u0026#34;(%g,%g)\u0026#34;,c.r,c.i) -- %g(%G) : 接受一个数字并将其转化为%e(%E,对应%G)及%f中较短的一种格式 end return M -- 加载时返回模块 使用上面编写的模块 1 2 3 4 -- D:/lua_note/chapter17/use_complex.lua package.path = package.path .. \u0026#39;;D:/lua_note/chapter17/?.lua\u0026#39; comp = require \u0026#34;complex\u0026#34; print(comp.tostring(comp.add(comp.new(1,2),comp.i))) -- (1,3) ","date":"2021-07-23T00:00:00Z","permalink":"https://Enco-Lee.github.io/p/lua-modules-and-packages/","title":"lua-modules and packages"},{"content":" metatables and metamethods\n元表让我们在面对一些未知操作时改变表的一些行为（通过 修改元表中的 元函数 实现运算符重载，控制table访问,修改键值操作\u0026hellip;）；\nlua中每一个值都可以有一个元表，table和 userdata类型的值具有单个元表；其他类型的值为该类型的所有值共享一个元表；\n但是在lua中只能修改 值类型 为table的元表，其他类型的元表修改需要通过C语言代码和debug库;\n修改和获取元表 setmetatable(tb,mt)：设置tb的元表为mt,并返回tb; getmetatable(tb): 获取到tb的元表； 上面两个方法实质都是通过元表中的__matetable进行相关操作,通过__matetable重新赋值可以保证元表的安全，即阻止这两个函数对元表进行操作； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 修改元表 local t = {} -- 普通表 local mt = {} -- 元表：里面主要放一些元方法 setmetatable(t,mt) -- 设置 mt 为 t 的元表 -- 以上两条语句等价于 local mytable = setmetatable({},{}) -- 获取元表 print(getmetatable(t) == mt) -- true print(getmetatable({})) -- nil print(getmetatable(\u0026#34;hello\u0026#34;)) -- table: 007E9A60 print(getmetatable(\u0026#34;lua\u0026#34;)) -- table: 007E9A60 print(getmetatable(111)) -- nil 常见的元方法 运算符元方法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --[[ -- __add\t: \u0026#39;+\u0026#39;. -- __sub\t: \u0026#39;-\u0026#39;. -- __mul\t: \u0026#39;*\u0026#39;. -- __div\t: \u0026#39;/\u0026#39;. -- __mod\t: \u0026#39;%\u0026#39;. -- __pow : \u0026#39;^\u0026#39; -- __unm\t: \u0026#39;-\u0026#39;. -- __concat\t: \u0026#39;..\u0026#39;. -- __eq\t: \u0026#39;==\u0026#39;. -- __lt\t: \u0026#39;\u0026lt;\u0026#39;. -- __le\t: \u0026#39;\u0026lt;=\u0026#39; -- __band ： \u0026#39;\u0026amp;\u0026#39; -- __bor : \u0026#39;|\u0026#39; ... --]] 其他元方法： 1 2 3 4 5 6 --[[ __tostring ： 对应于tostring __index： 访问元素触发 __newindex: 增加元素触发 __call:对象当作函数一样调用时触发 --]] 元方法的使用 运算符元方法和__tostring 通过编写运算符元方法实现运算符的重载\n编写简单的Set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 -- D:\\lua_note\\chapter20\\set.lua local Set = {} -- 注意这个lua文件名不能和这个名字一样，否则出现未定义错误。 local mt = {} -- set的元表 -- 创建一个集合，集合特性：1. 确定性；2. 互异性；3. 无序性； function Set.new(arr) -- arr = arr or {} -- 可对传的参数作缺省处理保证for迭代不出错 local set = {} setmetatable(set,mt) -- 使得每一个新建的set有相同的元表 for _,v in ipairs(arr) do -- 注意这里要记录的是v set[v] = true end return set end -- 集合并集 function Set.union(a,b) -- if getmetatable(a)~=mt or getmetatable(b)~=mt then -- error(\u0026#34;matetable is mismathching\u0026#34;) -- end local res = Set.new({}) -- 注意这里括号里要传一个table,否则new参数为nil无法构成迭代器而报错;或者new里对传参作缺省处理; for k in pairs(a) do res[k] = true end for k in pairs(b) do res[k] = true end return res end -- 集合交集 function Set.intersection(a,b) local res = Set.new({}) for k in pairs(a) do res[k] = b[k] end return res end -- 转换为字符串 function Set.tostring(set) local list = {} for e,_ in pairs(set) do list[#list + 1] = tostring(e) end -- table.sort(list) -- 显示时可以排个序方便观察，只是显示并没有对set内部产生任何影响 return \u0026#34;{\u0026#34; .. table.concat(list,\u0026#39;,\u0026#39;) .. \u0026#34;}\u0026#34; end -- 构建一个有序set function Set.sort(set) local st = {} for k,_ in pairs(set) do st[#st + 1] = k end table.sort(st) return setmetatable(st,mt) -- 这里只能重新构建一个有相同元表的“类Set“对象才能保证是一个有序set end -- 为元表添加元方法 -- 方式1 mt.__add = Set.union mt.__sub = Set.intersection mt.__tostring = Set.tostring -- 使得使用print输出直接为我们Set.tostring中设定的格式，因为print会自动调用tostring; -- 当使用io.write输出是需要显示调用tostring，即：io.write(tostring(set_obj)) -- 方式2 -- 子集：\u0026lt;= ，结合Set底层实现来编写比较逻辑 mt.__le = function (a,b) for k,_ in pairs(a) do if not b[k] then return false end end return true end -- 真子集：\u0026lt; mt.__lt = function (a,b) return a\u0026lt;=b and not (b\u0026lt;=a) end -- 相等： == mt.__eq = function (a,b) return a\u0026lt;=b and b\u0026lt;=a end --[[为了保证元表的安全: -- 即 不被getmetetable获取到真实元表 以及 setmatetable修改我们真实的元表， -- 只需为__metatable赋一个值即可； -- 即getmetetable和setmatetable获取和修改的只是元表中__metatable 的值; -- 思考： 也就是说__metatable 存的是 元表本身（self）？ --]] mt.__metatable = \u0026#34;you can\u0026#39;t get and change really metatable\u0026#34; return Set 测试Set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- D:\\lua_note\\chapter20\\test_set.lua package.path = package.path .. \u0026#39;;../lua_note/chapter20/?.lua\u0026#39; Set = require \u0026#34;set\u0026#34; local s1 = Set.new({1,2,3,4}) local s2 = Set.new({3,4,5,6}) -- local x = {1,4,6,8,9} -- for v in pairs(x) do -- 低版本的lua输出结果是content,lua 5.3输出了数字对应的key -- print(v) -- end print(getmetatable(s1)) print(getmetatable(s1) == getmetatable(s2)) -- true print(s1) -- {1,2,3,4} print(s2) -- {4,5,6,3} -- 可以发现s2乱序了，并不是按我们传入序列的顺序构建的， -- 原因是我们Set底层实现是key=val形式标记元素存在，存储在table底层的hash表中 s3 = s1 + s2 print(s3) -- {1,2,3,4,5,6} s4 = s1 - s2 print(s4) -- {4,3} io.write(tostring(s4)) -- {4,3} print(Set.sort(s2)) -- {1,2,3,4} print(getmetatable(s1) == getmetatable(s2)) -- true print(s4 \u0026lt;= s1) -- true print(s4 \u0026lt; s1) -- true print(Set.sort(s2) == s1) -- true local s3 = s1 + \u0026#34;hello\u0026#34; -- error print(s3) local s2 = s1 + 8 -- error print(s2) __index 如果访问table中没有定义的元素，经常返回nil; 原因： 访问字段是通过调用元函数__index来完成的，然而一般这个函数没有定义，所以我们访问没有定义的元素得到的是nil; 用途： 我们可以定义这个元函数来改变这种行为(比如访问一个不存在的元素时访问一个默认值)； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 local tb = {1111,x = 1,g = 10} local mt = {x = 2,y = 3} -- 访问一个不存在的元素时返回一个默认值 mt.__index = function () return \u0026#34;hhh\u0026#34; end print(tb.haaa,tb.ha,mt.la) -- hhh hhh nil local mt = {} function new(tb) setmetatable(tb,mt) return tb end local proto = {x = 1,y = 2,width = 3,height = 4} mt.__index = function (_,key) -- key作为第二个参数，思考：第一个参数是什么？ tip: 这种方式更复杂但更灵活，可以实现多继承； return proto[key] end local w = new{x = 10,y = 20} print(w.width) -- 3 local mp = {left = 1024,right = 2048} mt.__index = mp -- 也可以直接是一个table，这样相当于实现了单继承，继承了mp中的特性 print(w.left) -- 1024 访问表中元素的顺序: 先访问原始表，如果找到则直接返回，否则访问（调用）元表中的__index； rawget(tb,index)：即只读原始表，不访问(调用)元表中的__index; 1 2 3 4 5 6 7 8 local tb = {x = 1,g = 10} local mt = {__index = {x = 2,y = 3},z = 4} setmetatable(tb,mt) print(tb.x,tb.y,tb.z) -- 1 3, nil,从这里可以看出访问元素的顺序 print(tb.x,tb.y) -- 1 3 --原始表中没有y,去元表中访问（调用）__index print(rawget(tb,\u0026#34;x\u0026#34;),rawget(tb,\u0026#34;y\u0026#34;)) -- 1 nil，可见rawget不会访问__index __newindex 当我们给table中一个不存在的 index 赋值时， 如果定义了__newindex,则会调用这个元函数而不是直接进行赋值操作,可以借助这个特性保证table只可读; 和__index类似，如果这个元方法被赋值为另一个table,则不会对原table起作用，而是操作 赋值给这样元方法的table； 1 2 3 4 5 6 7 8 9 10 11 12 13 -- read only table function MakeReadOnly(t) mt = {} mt.__index = t mt.__newindex = function () error(\u0026#34;read only\u0026#34;) end return setmetatable(t,mt) end local t = {[\u0026#34;A\u0026#34;] = 1,[\u0026#34;B\u0026#34;] = 2,[\u0026#34;C\u0026#34;] = 1024,D = 2048} MakeReadOnly(t) t[\u0026#39;E\u0026#39;] = \u0026#34;hhhh\u0026#34; --error ： read only 不执行__newindex元方法的赋值操作： rawset(tb,k,v) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 local tb = {} local mt = { __newindex = function (tb,k,v) rawset(tb,k,v) print(\u0026#34;use newindex \u0026#34;,tb.b) end } print(\u0026#34;without matetable\u0026#34;) tb.a = 1 print(tb.a) setmetatable(tb,mt) print(\u0026#34;with matetable\u0026#34;) tb.b = 2 print(\u0026#34;direct rawset\u0026#34;) rawset(tb,\u0026#34;c\u0026#34;,3) print(tb.c) --[[output: without matetable 1 with matetable use newindex 2 direct rawset 3 --]] __call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- __call：当一个table当作函数调用时执行 local tb = {10,40,2,3,5} local mt = { __call = function (t,_) local sum = 0 for _,v in ipairs(t) do sum = sum + v; end print(\u0026#39;_ = \u0026#39;,_,\u0026#34;, sum = \u0026#34;,sum) return sum end } setmetatable(tb,mt) tb() -- _ = nil , sum = 60 tb(\u0026#34;test other\u0026#34;) -- _ = test other , sum = 60 -- call赋值的函数第一参数就是原来的表，后面可以有其他参数 ","date":"2021-07-21T00:00:00Z","permalink":"https://Enco-Lee.github.io/p/lua-metatables-and-metamethods/","title":"lua-metatables and  metamethods"},{"content":"函数调用形式 一般函数调用都要加括号,但是又两种特殊情况不需要：\ncase 1: 传的参数的是 一个 字符串（不是用变量保留的字符串） case 2: 传的参数的是 一个 表的构造 {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 print(os.date()) print \u0026#34;hello lua\u0026#34; function test_case1(str) assert(type(str) == \u0026#34;string\u0026#34;,\u0026#34;args must be a string\u0026#34;) print(str) end function test_case2(tb) assert(type(tb) == \u0026#34;table\u0026#34;,\u0026#34;args must be a table\u0026#34;) for k,v in ipairs(tb) do print (k,v) end end test_case1 \u0026#34;lua ~ \u0026#34; test_case2 {1,2,3} 函数特性 可以多返回值 函数参数个数可以不定的，参数列表 用 \u0026ldquo;\u0026hellip;\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 line = function () -- lambda 函数 print(string.rep(\u0026#39;-\u0026#39;,15)) end line() -- 函数可以返回多个值 function get_max_min(list) min = math.maxinteger max = math.mininteger for _,v in ipairs(list) do max = math.max(max,v) -- max 和 min 函数在低版本的 lua 没有 min = math.min(min,v) end return max,min end a = {2,5,7,3,9,8,1} print(get_max_min(a)) -- 函数参数个数可以不定的，参数列表 用 \u0026#34;...\u0026#34; function my_max(...) max = math.mininteger for _,v in ipairs(...) do max = math.max(max,v) end return max end print(my_max(a)) line() -- 对于 选择 序列 哪部分内容 可以 用 select print(select(2,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;)) --从第 2 个开始选择;output: b c print(type(select(2,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;))) -- string print(type(select(2,1,2,3))) -- number x,y = select(2,1,2,3) print(x,y) -- 2 3 print(select(\u0026#39;#\u0026#39;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;)) -- 若第一个参数为字符 \u0026#39;#\u0026#39;，则返回之后序列的长度，output: 3 -- select 可用于计算不定参数的个数 以及对她进行选择 function select_test(...) sum = 0 for i = 1,select(\u0026#39;#\u0026#39;,...) do sum = sum + select(i,...) -- 此时计算 只会加上所选序列的第一个数，之后的自动忽略 end return sum end print(select_test(1,2,3,4,5)) line() --[[ --注意：select(1,...)返回的是一个序列，但是这里是不可以迭代，思考： ipairs 和 pairs 只能适用于 table ? function select_test2(...) sum = 0 for _,v in ipairs(select(1,...)) do -- error： ipairs(select(1,...)) 不是一个可迭代对象 sum = sum + v end return sum end print(select_test2(1,2,3,4,5)) --]] ","date":"2021-07-19T00:00:00Z","permalink":"https://Enco-Lee.github.io/p/lua-function/","title":"lua-function"},{"content":"table的key以及存储机制 {}表示table,它可以以除nil外的任何对象作为key； table的底层由 数组 和 hash表 构成；\n当增加一个很大的key使得存储空间利用率低于50%时，这个key会被hash，然后放入hash表存储；\n0，负数，string 作为key时都是被放在hash表存储；\ntable的底层的 数组 或者 hash表 满时，都是以2倍扩容；\nhash表大小是2的倍数，只有当hash表满了，才会重新分配 数组和 hash表的空间；\nref:https://blog.csdn.net/zr339361504/article/details/52432163\ntable计算长度: 采用#table_name 计算table长度\n注意：\n对于带nil的列表，用#计算其长度是不可靠的, 所以它只适用于没有nil的列表; 没有正整数作为key的列表长度为0； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 b = {1,5,nil,10,nil,1024,nil,nil} print(#b) -- 6 c = {1,5,nil,10,nil,1024,nil,nil,x = 3} print(#c) -- 6 -- 以上两种 发现是返回最后不是nil处的index d = {1,5,nil,10,nil,1024,nil,nil,x = 3,233} -- 等价于计算{1,5,nil,10,nil,1024,nil,nil,233} print(#d) -- 9 -- 发现键值对的并没有算进去，因为它存在底层的hash表中，#此时只计算底层的array的长度 e = {x = 1,y = 2,[\u0026#39;z\u0026#39;] = 3} print(#e) -- 0 f = {x = 1,y = 2,[1] = 2} print(#f) --1 g = {x = 2,[2.1] = 3,[-1] = 3} print(#g) --0,发现并没有计算hash表部分 #求长度伪代码： 1 2 3 4 5 6 7 8 9 if 数组最后一位 == nil then 则二分查找往前找到一个不是nil的返回长度 else if 数组最后一位 ~=nil and 散列桶部分 == nil then return 数组长度 else 计算散列桶部分的长度 local function 计算散列桶部分的长度() 从数组长度+1 开始查找, 同样二分查找 （只针对散列桶部分的key为正整数的数据） end 所以使用table时：\n尽量放同一类元素，不要 使得 底层的array 和hash表 都被使用; 存在nil的table 求长度不稳定; 尽量使用数组部分，尽量避免重新散列操作（hash表满后 会 重新分配底层的array和hash表的内存，严重影响效率）; table 的遍历方式 方式1: 1 2 3 4 5 print(\u0026#39;-----normal--------\u0026#39;) -- 与ipairs 等价： 遇到nil终止无法遍历到 键值对元素 for i = 1 , #tb do print(i , tb[i]) end 方式2： 1 2 3 4 5 -- ipairs 遇到nil终止，无法遍历到 键值对元素 print(\u0026#34;-----ipairs--------\u0026#34;) for k,v in ipairs(tb) do print(k,v) end 方式3： 1 2 3 4 5 -- k,v形式遍历table,能遍历到所有元素 print(\u0026#34;-----paris--------\u0026#34;) for k,v in pairs(tb) do print(k,v) end 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 tb = {} tb[\u0026#39;x\u0026#39;] = 1 tb[2.1] = 2021 print(tb[2.1],tb.x) tb[2] = 2 print(tb[2]) -- table是匿名对象，保存table的变量是对表的引用，当表的引用计数为0时会被gc自动回收 tb2 = tb tb = nil print(tb2[\u0026#39;x\u0026#39;]) -- 依然有效 tb2.y = 10 -- 等价于tb2[\u0026#39;y\u0026#39;] = 10 print(tb2.y,tb2[\u0026#39;y\u0026#39;]) -- table 构造列表可以是 单个值 以及 键值对 的形式 list = {x = 1,\u0026#34;hello\u0026#34;,y = 2,math.pi} print(list.x) -- 注意: 构造列表，起始索引1 从 第一个 非键值对的元素 算起,依次对这类元素进行index++ print(list[0],list[1]) -- nil hello print(list[2],list[-1]) -- 3.1415926535898 nil list[-1] = 1024 list[0] = 2021 list[1] = \u0026#34;world\u0026#34; -- k,v形式遍历table,能遍历到所有元素 print(\u0026#34;-----paris--------\u0026#34;) for k,v in pairs(list) do print(k,v) end -- ipairs 遇到nil终止，无法遍历到 键值对元素 print(\u0026#34;-----ipairs--------\u0026#34;) for k,v in ipairs(list) do print(k,v) end --[[ output: -----paris-------- 1 world 2 3.1415926535898 y 2 x 1 -1 1024 0 2021 -----ipairs-------- 1 world 2 3.1415926535898 --]] print(\u0026#39;-----normal--------\u0026#39;) -- ipairs 等价于以下我们常用的方式: for i = 1 , #list do print(i , list[i]) end 常用函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 --useful functions in table library -- 增加 和 移除 t = {1,2,3,4,5,6} print(t[6]) table.insert(t,6,7) -- table, pos ，val print(t[6],t[7]) x = table.remove(t,7) -- table，pos,返回该位置的值 print(x) table.insert(t,8) -- table,val ：默认插在最后 print(t[#t]) --[[ t = {} for line in io.lines() do -- ctrl+z 结束输入 table.insert(t,line) end print(#t) for k,v in pairs(t) do print(k,v) end --]] print(string.rep(\u0026#39;-\u0026#39;,10)) function print_table(a) for k,v in ipairs(a) do print(k,v) end end -- 移动元素 a = {1,2,3,4,5,6} -- move在5.3版本有，但是之前的5.1版本却不存在 print(#a) table.move(a,1,#a,2) -- a[1...#a] = a[2...2+#a],即整体后移一位 print(#a) print_table(a) -- 可以发现空出的位置a[1]的值没有发生变化 print(string.rep(\u0026#39;-\u0026#39;,10)) a[1] = 1024 --这时相当于 头部 增加一个元素 table.move(a,2,#a,1) print_table(a) -- 空出的位置a[#a]值 依然不变,a[1]位置上的值被覆盖了 print(#a) a[#a] = nil -- 尾部置nil,此时 真正意义上 删掉了一个元素 而且 是 头部元素 print(#a) -- 由上面两个测试 可以大致推断table中move 实现 function move(a,s,e,pos) if pos == s then return a end while s \u0026lt;= e do a[pos] = a[s] pos = pos + 1 s = s + 1 end return a end print(string.rep(\u0026#39;-\u0026#39;,10)) a = {1,2,3,4,5,6} -- print(table.move(a,3,5,2) == move(a,3,5,2)) -- true -- print_table(a) -- after: {1,3,4,5,5,6} print(table.move(a,1,#a,2) == move(a,1,#a,2)) -- true print_table(a) print(string.rep(\u0026#39;-\u0026#39;,10)) b = {2,6,7,3,9,2,1} -- 排序 : 默认升序 table.sort(b) print_table(b) print(string.rep(\u0026#39;-\u0026#39;,10)) -- 自己写比较规则 table.sort(b,function (a,b) return a \u0026gt; b -- 降序 end) print_table(b) -- 将元素连接成一个字符串 print(table.concat(b,\u0026#39;-\u0026#39;,1,#b)) ","date":"2021-07-19T00:00:00Z","permalink":"https://Enco-Lee.github.io/p/lua-table/","title":"lua-table"}]