[{"content":" 不可真virtuel的函数可以借助可真virtuel的成员函数达到伪virtual。比如构造函数和非成员函数的\u0026quot;虚\u0026quot;化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Component { public: virtual std::ostream\u0026amp; print(std::ostream\u0026amp; out) const = 0; }; class AComponent :public Component { public: virtual std::ostream\u0026amp; print(std::ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;A\u0026#34;; return out; } }; class BComponent :public Component { public: virtual std::ostream\u0026amp; print(std::ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;B\u0026#34;; return out; } }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, Component\u0026amp; c) { return c.print(out); } // 使用 AComponent a; BComponent b; std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 当没有namespace限定作用域时，类中friend函数为全局作用域，而类中static作用域限定在类空间\n多用namespace, 可以避免命名冲突，同时某些时候可以简化书写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace PrintingStuff { class Printer { private: Printer() {}; //... public: void doX() {}; void doY() {}; //... friend Printer\u0026amp; thePrinter(); }; Printer\u0026amp; thePrinter() { static Printer printer; return printer; } } // 使用 using PrintingStuff::thePrinter; thePrinter().doX(); thePrinter().doY(); 不要将含local static对象的非成员函数inline化：由于inline函数复制可能导致产生多个static对象副本\n避免具体类继承具体类\npass\n实现String类：引用计数，写时复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 // version 1 // my_string.h #pragma once #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; namespace MyStr { class String { public: String(const char* str=\u0026#34;\u0026#34;); String(const String\u0026amp; s); String\u0026amp; operator=(const String\u0026amp; s); ~String(); const char\u0026amp; operator[](size_t index) const; char\u0026amp; operator[](size_t index); // 重载实现写时复制 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, String\u0026amp; s); private: struct StringValue { char* m_data; int m_refCount; StringValue(const char* str) :m_refCount(1) { size_t len = std::strlen(str); m_data = new char[len + 1]; std::strncpy(m_data, str, len); m_data[len] = \u0026#39;\\0\u0026#39;; }; ~StringValue() { delete[] m_data; } }; StringValue* m_pValue; }; } // my_string.cpp #include \u0026#34;my_string.h\u0026#34; namespace MyStr { String::String(const char* str):m_pValue(new StringValue(str)) { } String::String(const String\u0026amp; s) { m_pValue = s.m_pValue; ++m_pValue-\u0026gt;m_refCount; } String\u0026amp; String::operator=(const String\u0026amp; s) { if (m_pValue == s.m_pValue) { return *this; } if (--m_pValue-\u0026gt;m_refCount == 0) { delete m_pValue; } m_pValue = s.m_pValue; ++m_pValue-\u0026gt;m_refCount; return *this; } String::~String() { if (--m_pValue-\u0026gt;m_refCount == 0) { delete m_pValue; } } const char\u0026amp; String::operator[](size_t index) const { return m_pValue-\u0026gt;m_data[index]; } char\u0026amp; String::operator[](size_t index) { if (m_pValue-\u0026gt;m_refCount \u0026gt; 1) { --m_pValue-\u0026gt;m_refCount; m_pValue = new StringValue(m_pValue-\u0026gt;m_data); } return m_pValue-\u0026gt;m_data[index]; } std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, String\u0026amp; s) { out \u0026lt;\u0026lt; s.m_pValue-\u0026gt;m_data; return out; } } ","date":"2022-08-31T00:00:00Z","permalink":"https://example.com/p/more-effective-c-%E6%8A%80%E6%9C%AF%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/","title":"《More Effective C++》技术章节笔记"},{"content":"thread 基础概念：\n并发：一个处理器在一定时间间隔(时间片)内轮流执行任务。 多任务是抢占资源的。\n并行：多个处理器同一时间点上同时执行任务。 不抢占资源。\n临界资源： 在一段时间内仅允许一个进程访问的资源。比如打印机，各个进程采用互斥的方式实现对资源的共享，\n临界区： 每个进程访问临界资源的那段代码和共享变量有关的程序段。\n并发的实现方式 通过多个进程实现并发 通过创建多个线程实现并发 进程间通信 同一电脑： 管道，共享内存，文件， 消息队列 不同电脑： socket通信 线程间通信 共享内存，比如使用全局变量 共享数据分析： 只读数据：它是安全的稳定的，直接读即可； 有读有写：不安全，最简单处理：读写互斥 死锁 只有至少有两把锁才可能出现死锁\n描述：1持有A，想要B；2持有B，想要A。导致1,2无法继续执行的僵持状态\n互斥量：用于多线程编程种保护共享数据\n解决死锁：\n多个互斥量，保存相同的上锁顺序\n当多个互斥量时，使用std::lock()进行上锁，这个接口使得上锁顺序无关：std::lock(mtx1, mtx2), 还是记住需要手动解锁， 可配合std::lock_guard避免手动解锁：\n1 2 3 std::lock(m1, m2); // 一次性锁多个 std::lock_guard\u0026lt;std::mutex\u0026gt;(m1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt;(m2, std::adopt_lock); API 1 2 3 thread t(func); // 传入一个可调用对象: 函数对象，lambda函数， 仿函数等 t.join(); // 阻塞主线程 等子线程执行完后与主线程汇合 t.deatch(); // 分离，子线程执行不可控，子线程和主线程各自执行各的，主线程不需要等待， 子线程执行完毕有接管他的运行时库进行清理 一般不需要关心或者控制子线程的执行时就调用detach 使用detach时，需要避免线程入口函数的传参隐式类型的转换，防止局部对象失效， 可以显示构造一个临时对象传入避免不安全使用对象 尽可能不使用detach 明确往线程对象入口函数参数指定需要传入真引用则必须使用std::ref，否则都是默认拷贝，但是传真引用只有使用join才是安全的 lock_guard std::lock_gurad\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock), std::adopt_lock适应之前mtx已经了lock，从而不再lock unique_lock 可以完全取代lock_guard, 而且更灵活，但是占有更多空间，相比std::adopt_lock还有其他参数\nstd::try_to_lock:尝试用mutex的lock()去锁定mutex， 如果没有锁成功也立即返回不会阻塞，但需要注意std::try_to_lock之前不能手动调用mutex的lock()否则会卡死。unique_lock对象成员函数owns_lock() 可以 判断有没有拿到锁\nstd::defer_lock: 初始化一个没有加锁的mutex， 使用前提也是不能对传入的mutex对象lock()，否则报异常。\n成员函数：\nlock() unlock()：虽然会自动加锁解锁，但是提供lock和unlock是为了临时解锁处理一些非共享代码 try_lock(): return true or false release():释放管理的mutex的所有权，返回之前管理的mutex对象的指针，之后需要我们自己负责mutex对象的unlock unique_lock对象所有权转移方法：使用std::move； 通过一个函数作为临时对象返回；\n条件变量 std::condition_variable:需要结合互斥量进行使用 wait(): 第一个参数为互斥量对象\n没有第二个参数，则解锁互斥量，当前线程执行阻塞到本行，直到其他线程notify_one；\n如果第二个参数为lambda，若lambda返回true则wait直接返回继续执行，否则解锁互斥量，阻塞到本行，直到被notify_one\n当被唤醒时： 重新尝试对互斥量加锁，直到加锁成功后继续往下执行\n虚假唤醒：即使没有notify该线程也有概率会唤醒，处理：wait中要第二个参数（lambda）并正确判断要处理的共享数据是否存在\n有可能出现一个线程还没走到wait时，notify消息就发送了，此时后面就可能导致盲目等待了，所以执行wait需要判断一些条件\nnotify_one():尝试把wait的线程唤醒\nfuture vaild(): 判断值是否有效\nshare(): 用于future对象构造shared_future，比如std::shared_future sf(f.share());\nfuture_status\n1 pass shared_future: 用于多个线程获取future数据，由于普通future对象只支持get一次，std::shared_future\u0026lt;int\u0026gt; sf = std::thread([]{return 1;});\natomic 原子操作概念：不可分割的操作，要么完成要么未完成， 不可能出现中间状态。在多线程种不会被打断的程序执行片段。 效率上比互斥量更高。适用于一个变量而不是一个代码段。能用原子操作就不用互斥量；一般针对++, --, +=, -=操作符，其他的不一定支持原子操作，比如x = x + 1不支持原子操作。 load()原子方式读取值，没有拷贝构造和赋值操作符， 可以这样进行复制：std::atomic\u0026lt;int\u0026gt; m2(m1.load()); store(v)原子方式写入值，std::atomic\u0026lt;int\u0026gt;m1 = 0; m1.store(1); async 用于创建异步任务\n第一个标志参数指定std::launch::async：强制异步任务在新线程中执行， 当future对象调用get或者wait时执行\n当第一个标志参数使用std::launch::deferred：不会创建新线程，会到主线程中执行，如果future没有get或者wait将不执行\n当第一个标志参数为std::launch::async | std::launch::deferred ,由系统评估选择其一执行，当第一个参数不传入标志参数时，默认就是这种参数。\n当系统资源紧张的时候，使用std::thread可能创建线程失败，出现程序奔溃\n相比std::thread,std::async获取入口参数返回值更简单，由于可以默认由系统决定是否创建新线程，在资源紧张情况下，这种方式也更安全\n经验： 一个程序不宜超过100-200个线程\n当为默认标志参数时，系统采用的策略（std::launch::async ，std::launch::deferred）确定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 std::future\u0026lt;int\u0026gt; ret = std::async([]() { std::this_thread::sleep_for(std::chrono::milliseconds(5000)); std::cout \u0026lt;\u0026lt;\u0026#34; async this_thread id \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; std::endl; return 1024;}); std::future_status status = ret.wait_for(std::chrono::seconds(0)); if (status == std::future_status::deferred) { // 延迟执行，由于资源紧张没有创建新线程，将在主线程中执行 std::cout \u0026lt;\u0026lt; \u0026#34;deferred\u0026#34; \u0026lt;\u0026lt; std::endl; //这个时候在主线程中执行 std::cout \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; std::endl; } else // 创建了新线程执行 { if (status == std::future_status::ready) { // 线程执行完毕，成功返回 std::cout \u0026lt;\u0026lt; \u0026#34;ready\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; std::endl; } else if (status == std::future_status::timeout) { // 线程还在执行 std::cout \u0026lt;\u0026lt; \u0026#34;timeout\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; std::endl; } } windows下的临界区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;vector\u0026gt; class A { public: A() { InitializeCriticalSection(\u0026amp;_wCS); } CRITICAL_SECTION _wCS; // 相当于std::mutex void pushValue(int v) { EnterCriticalSection(\u0026amp;_wCS); // 相当于lock //EnterCriticalSection(\u0026amp;_wCS); vec.push_back(v); //LeaveCriticalSection(\u0026amp;_wCS); LeaveCriticalSection(\u0026amp;_wCS); // unlock } private: std::vector\u0026lt;int\u0026gt; vec; }; class WindowsLockGuard { public: WindowsLockGuard(CRITICAL_SECTION* wcs):_pCS(wcs){ EnterCriticalSection(_pCS); } ~WindowsLockGuard() { LeaveCriticalSection(_pCS); } private: CRITICAL_SECTION* _pCS; }; windows中允许在同一个线程中（不同线程会卡住等待）进入同一个临界区多次, c++11不允许在同一线程中lock普通互斥量多次，否则报异常； recursive_mutex 允许在同一线程中同一个递归互斥量多次lock 一般使用它是代码设计的不太好，使用后需要考虑是否有优化空间，使得只lock一次 带超时的互斥量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 std::timed_mutex t_mtx; std::recursive_timed_mutex rt_mtx; if (t_mtx.try_lock_for(std::chrono::seconds(2))) // 尝试等待2s 获取锁 { // 保护内容 t_mtx.unlock(); } else // 普通mutex没拿到锁会阻塞，没法走下这里 { // 没有拿到锁 // 可以处理不需要保护内容 } // 直到某个时间点获取锁 if (t_mtx.try_lock_until(std::chrono::steady_clock::now() + std::chrono::milliseconds(1000))) { } else { } ","date":"2022-08-31T00:00:00Z","permalink":"https://example.com/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/","title":"c++多线程总结"},{"content":"一个简单的lua 解释器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // simpleLuaInterpreter.cpp : 此文件包含 \u0026#34;main\u0026#34; 函数。程序执行将在此处开始并结束。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #include \u0026#34;lua.h\u0026#34; // 高度抽象化的基础API #include \u0026#34;lauxlib.h\u0026#34; // 包含辅助库函数声明，函数以luaL_开头 #include \u0026#34;lualib.h\u0026#34; // 包含打开库的函数的声明 #ifndef __cpluscplus } #endif // !__cpluscplus // 辅助库没有方式去解释lua,只能通过lua.h中的基础API /* Lua库根本没有定义C的全局变量,它将其所有状态保持在动态结构中。 Lua内部的所有函数都会收到指向该结构的指针。 */ // #include \u0026#34;lua.hpp\u0026#34; //可代替extern \u0026#34;C\u0026#34;{#include \u0026#34;lua.h\u0026#34;} int main() { char buff[256]; int error; lua_State* L = luaL_newstate(); // 创建一个新状态但是它的环境中没有预先定义任何函数 luaL_openlibs(L); // 打开所有标准库 // luaL_loadstring:编译用户输入，如果不出错，return0并将结果压入stack // lua_pcall 不出错return 0 // 两个函数出错会将错误信息压入stack while (fgets(buff, sizeof(buff), stdin) != NULL) { error = luaL_loadstring(L, buff) || lua_pcall(L, 0, 0, 0); if (error) { fprintf(stderr, \u0026#34;%s\\n\u0026#34;, lua_tostring(L, -1)); lua_pop(L, 1); } lua_close(L); } std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;; return 0; } lua 和 C 组件的通信 lua 和 C 主要组件的通信 是通过强大的虚栈（virtual stack）\n虚栈压入元素 1 2 3 4 5 6 void lua_pushnil (lua_State *L); void lua_pushboolean (lua_State *L, int bool); void lua_pushnumber (lua_State *L, lua_Number n); void lua_pushinteger (lua_State *L, lua_Integer n); void lua_pushlstring (lua_State *L, const char *s, size_t len); void lua_pushstring (lua_State *L, const char *s); 向栈中压入元素前要保证stack中至少有20个空位（slots）,在lua.h中定义了这个常量宏：LUA_MINSTACK； 检查虚栈空间是否足够的函数：\nint lua_checkstack (lua_State *L, int sz); void luaL_checkstack (lua_State *L, int sz, const char *msg); 参数sz是需要检查的slots数量，第二个函数使得可以返回一个自定义的出错信息而不是错误码；\n虚栈提取元素 index可正可负，第一个压入元素（栈底）的index=1,最后压入元素（栈顶）的index=-1；\n获取栈中元素个数：size_t n = lua_gettop(L)；\n检查获取元素的类型 可以使用：int lua_is* (lua_State *L, int index);,*换成想要检查的lua数据类型 ，比如lua_isnil,lua_isstring。lua_isnumber和lua_isstring比较特殊，两者并不能确定元素类型而是是检查index位置上的元素是否可以转换为该类型。除此之外可以使用lua_type(L,index)获取到元素类型，返回值是lua.h中定义的宏，比如：LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER, LUA_TSTRING。\n获取元素的函数：\nint lua_toboolean (lua_State *L, int index); // nil和false时为0，其他类型元素为1 const char *lua_tolstring (lua_State *L, int index,size_t *len); // 同时获取字符串长度，存到len中 const char *lua_tostring (lua_State *L, int index); // 不需要长度信息可使用这个函数获取字符串 lua_State *lua_tothread (lua_State *L, int index); // index处获取一个线程，失败时返回NULL lua_Number lua_tonumber (lua_State *L, int index); lua_Integer lua_tointeger (lua_State *L, int index); 其他虚栈操作 int lua_gettop (lua_State *L); // 获取栈元素个数，也是栈顶的的正index void lua_settop (lua_State *L, int index); // 当index大于现在栈元素个数时补nil,小于时丢弃多的，置空：lua_settop(L,0) void lua_pushvalue (lua_State *L, int index); // 拷贝一个index处的元素压入栈中 void lua_rotate (lua_State *L, int index, int n); // 从index处到栈顶，旋转n个位置 void lua_remove (lua_State *L, int index); // 移除index处元素 void lua_insert (lua_State *L, int index); // 将index处元素放到栈顶 void lua_replace (lua_State *L, int index); // 弹出栈顶元素赋值到index处 void lua_copy (lua_State *L, int fromidx, int toidx); lua_settop (lua_State *L, int index)的index也可以是负下标，由此定义了一个弹出n个元素的宏#define lua_pop(L,n) lua_settop(L,-(n)-1)比如弹出3个元素，lua_pop(L,3) =\u0026gt;lua_settop(L,-4),栈顶-1设置成-4，由-1 to -4 弹出了3个元素；\nremove宏可通过rotate和pop来实现：#define lua_remove(L,idx) (lua_rotate(L, (idx), -1), lua_pop(L, 1))\ninsert 的宏实现#define lua_insert(L,idx) lua_rotate(L, (idx), 1)\nlua_rotate 源码： 1 2 3 4 5 6 7 8 9 10 11 12 LUA_API void lua_rotate (lua_State *L, int idx, int n) { StkId p, t, m; lua_lock(L); t = L-\u0026gt;top - 1; /* end of stack segment being rotated */ p = index2stack(L, idx); /* start of segment */ api_check(L, (n \u0026gt;= 0 ? n : -n) \u0026lt;= (t - p + 1), \u0026#34;invalid \u0026#39;n\u0026#39;\u0026#34;); m = (n \u0026gt;= 0 ? t - n : p - n - 1); /* end of prefix */ reverse(L, p, m); /* reverse the prefix with length \u0026#39;n\u0026#39; */ reverse(L, m + 1, t); /* reverse the suffix */ reverse(L, p, t); /* reverse the entire segment */ lua_unlock(L); } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; { #include \u0026#34;lua.h\u0026#34; // 高度抽象化的基础API #include \u0026#34;lauxlib.h\u0026#34; // 包含辅助库函数声明，函数以luaL_开头 #include \u0026#34;lualib.h\u0026#34; // 包含打开库的函数的声明 } static void dumpStack(lua_State* L) { size_t n = lua_gettop(L); for (size_t i = 1; i \u0026lt;= n; ++i) { int t = lua_type(L, i); switch (t) { case LUA_TBOOLEAN: { std::cout \u0026lt;\u0026lt; (lua_toboolean(L, i) ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) \u0026lt;\u0026lt; std::endl; break; } case LUA_TSTRING: { std::cout \u0026lt;\u0026lt; (lua_tostring(L, i)) \u0026lt;\u0026lt; std::endl; break; } case LUA_TNUMBER: { if (lua_isinteger(L, i)) { std::cout \u0026lt;\u0026lt; lua_tointeger(L, i) \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; lua_tonumber(L, i) \u0026lt;\u0026lt; std::endl; } break; } default: { std::cout \u0026lt;\u0026lt; lua_typename(L, i) \u0026lt;\u0026lt; std::endl; break; } } } } class SmartLuaState { public: SmartLuaState(lua_State* LL=nullptr):L(LL) { } ~SmartLuaState() { if (L != nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;close lua_State\u0026#34; \u0026lt;\u0026lt; std::endl; lua_close(L); } } void pushnil() { lua_pushnil(L); } void pushboolean(int n) { lua_pushboolean(L, n); } void pushstring(const char *s) { lua_pushstring(L, s); } lua_State* get_state() { return L; } void dumpStack(); void rotate(int index,int n) { lua_rotate(L, index, n); } void insert(int index) { lua_insert(L, index); } private: lua_State* L; }; void SmartLuaState:: dumpStack() { std::cout \u0026lt;\u0026lt; \u0026#34;values of stack\u0026#34; \u0026lt;\u0026lt; std::endl; size_t n = lua_gettop(L); for (size_t i = 1; i \u0026lt;= n; ++i) { int t = lua_type(L, i); switch (t) { case LUA_TBOOLEAN: { std::cout \u0026lt;\u0026lt; (lua_toboolean(L, i) ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) \u0026lt;\u0026lt; std::endl; break; } case LUA_TSTRING: { std::cout \u0026lt;\u0026lt; (lua_tostring(L, i)) \u0026lt;\u0026lt; std::endl; break; } case LUA_TNUMBER: { if (lua_isinteger(L, i)) { std::cout \u0026lt;\u0026lt; lua_tointeger(L, i) \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; lua_tonumber(L, i) \u0026lt;\u0026lt; std::endl; } break; } default: { std::cout \u0026lt;\u0026lt; lua_typename(L, i) \u0026lt;\u0026lt; std::endl; break; } } } } static void test1() { SmartLuaState smt = SmartLuaState(luaL_newstate()); lua_State* L = smt.get_state(); lua_pushboolean(L, 1); lua_pushnumber(L, 10); lua_pushnil(L); lua_pushstring(L, \u0026#34;hello\u0026#34;); dumpStack(L); std::cout \u0026lt;\u0026lt; \u0026#34;--- hello lua -- \u0026#34; \u0026lt;\u0026lt; std::endl; smt.dumpStack(); } static void test2() { SmartLuaState state = SmartLuaState(luaL_newstate()); state.pushstring(\u0026#34;a\u0026#34;); state.pushstring(\u0026#34;b\u0026#34;); state.pushstring(\u0026#34;c\u0026#34;); state.pushstring(\u0026#34;d\u0026#34;); state.dumpStack(); state.rotate(2, 4); //state.insert(2); state.dumpStack(); //state.rotate(2, -1); } int main() { // test1(); test2(); return 0; } ","date":"2021-07-25T00:00:00Z","image":"https://example.com/p/lua-c-api/capi-01_huca6d7e28af0b1415d7250274d96385f1_25992_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/lua-c-api/","title":"lua-C API"},{"content":" modules and packages , lua 5.1 后 提供了一系列模块和包策略\npackage 是 modules 的集合 加载使用模块 1 2 local m = require \u0026#34;math\u0026#34; print(m.sin(3.14)) -- 0.0015926529164868 require 的参数和返回值 参数 require只需要传入一个参数 1 2 3 4 5 6 7 8 math = require(\u0026#34;math\u0026#34;) -- 只有当这个参数是纯字符串时，括号才是可选的 string = require \u0026#34;string\u0026#34; -- 解释器是通过式预加载的方式载入模块，所以我们可以修改预加载好的模块标识而不影响原来的库 math.sin = print math.sin(1,2,3) -- 1 2 3 cos = require \u0026#34;math\u0026#34;.cos -- 也可以加载特定的函数，这种参数不能加() print(cos(3.14)) -- -0.99999873172754 返回值 如果加载成功，模块有返回值，就是模块返回值的类型，如果没有返回值，返回值为boolean类型; 模块加载失败会报错 ; ref; 其他 一旦某个模块已经加载成功，其他需要用这个模块的调用都只需返回这个模块，而不需执行其他代码（比如查找模块等） 加载操作时查找lua模块的路径存在package.path中,加入 查找路径 示例： 1 package.path = package.path .. \u0026#39;;D:/lua_note/chapter17/?.lua\u0026#39; -- 注意添加路径前需要加\u0026#34;;\u0026#34; 如果在lua文件中没有找到这个模块，会去搜索C的模块，搜索路径为：package.cpath 为了避免相同模块被加载两次，可以这样设置： 1 package.loaded.modname = nil 编写lua模块 简单示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 -- D:/lua_note/chapter17/complex.lua:一个简单的复数模块 local M = {} --package.loaded[...] = M -- 前面放进去后面就不用返回值 -- 创建一个新的复数:z = ar+bi -- 实部：[r] = r,虚部：[i] = i local function new(r,i) return {r=r,i=i} end M.new = new --将new函数加入模块 -- 纯虚数 z = i M.i = new(0,1) -- 复数相加 function M.add(c1,c2) return new(c1.r+c2.r,c1.i+c2.i) end -- 复数相减 function M.sub(c1,c2) return new(c1.r-c2.r,c1.i-c2.i) end -- 复数相乘 function M.mul(c1,c2) return new(c1.r*c2.r-c1.i*c2.i,c1.r*c2.r+c1.i*c2.i) end local function inv(c) local n = c.r^2 + c.i^2 return new(c.r/n,-c.i/n) end -- 复数相除 function M.div(c1,c2) return M.mul(c1,inv(c2)) end function M.tostring(c) return string.format(\u0026#34;(%g,%g)\u0026#34;,c.r,c.i) -- %g(%G) : 接受一个数字并将其转化为%e(%E,对应%G)及%f中较短的一种格式 end return M -- 加载时返回模块 使用上面编写的模块 1 2 3 4 -- D:/lua_note/chapter17/use_complex.lua package.path = package.path .. \u0026#39;;D:/lua_note/chapter17/?.lua\u0026#39; comp = require \u0026#34;complex\u0026#34; print(comp.tostring(comp.add(comp.new(1,2),comp.i))) -- (1,3) ","date":"2021-07-23T00:00:00Z","permalink":"https://example.com/p/lua-modules-and-packages/","title":"lua-modules and packages"},{"content":" metatables and metamethods\n元表让我们在面对一些未知操作时改变表的一些行为（通过 修改元表中的 元函数 实现运算符重载，控制table访问,修改键值操作\u0026hellip;）；\nlua中每一个值都可以有一个元表，table和 userdata类型的值具有单个元表；其他类型的值为该类型的所有值共享一个元表；\n但是在lua中只能修改 值类型 为table的元表，其他类型的元表修改需要通过C语言代码和debug库;\n修改和获取元表 setmetatable(tb,mt)：设置tb的元表为mt,并返回tb; getmetatable(tb): 获取到tb的元表； 上面两个方法实质都是通过元表中的__matetable进行相关操作,通过__matetable重新赋值可以保证元表的安全，即阻止这两个函数对元表进行操作； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 修改元表 local t = {} -- 普通表 local mt = {} -- 元表：里面主要放一些元方法 setmetatable(t,mt) -- 设置 mt 为 t 的元表 -- 以上两条语句等价于 local mytable = setmetatable({},{}) -- 获取元表 print(getmetatable(t) == mt) -- true print(getmetatable({})) -- nil print(getmetatable(\u0026#34;hello\u0026#34;)) -- table: 007E9A60 print(getmetatable(\u0026#34;lua\u0026#34;)) -- table: 007E9A60 print(getmetatable(111)) -- nil 常见的元方法 运算符元方法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --[[ -- __add\t: \u0026#39;+\u0026#39;. -- __sub\t: \u0026#39;-\u0026#39;. -- __mul\t: \u0026#39;*\u0026#39;. -- __div\t: \u0026#39;/\u0026#39;. -- __mod\t: \u0026#39;%\u0026#39;. -- __pow : \u0026#39;^\u0026#39; -- __unm\t: \u0026#39;-\u0026#39;. -- __concat\t: \u0026#39;..\u0026#39;. -- __eq\t: \u0026#39;==\u0026#39;. -- __lt\t: \u0026#39;\u0026lt;\u0026#39;. -- __le\t: \u0026#39;\u0026lt;=\u0026#39; -- __band ： \u0026#39;\u0026amp;\u0026#39; -- __bor : \u0026#39;|\u0026#39; ... --]] 其他元方法： 1 2 3 4 5 6 --[[ __tostring ： 对应于tostring __index： 访问元素触发 __newindex: 增加元素触发 __call:对象当作函数一样调用时触发 --]] 元方法的使用 运算符元方法和__tostring 通过编写运算符元方法实现运算符的重载\n编写简单的Set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 -- D:\\lua_note\\chapter20\\set.lua local Set = {} -- 注意这个lua文件名不能和这个名字一样，否则出现未定义错误。 local mt = {} -- set的元表 -- 创建一个集合，集合特性：1. 确定性；2. 互异性；3. 无序性； function Set.new(arr) -- arr = arr or {} -- 可对传的参数作缺省处理保证for迭代不出错 local set = {} setmetatable(set,mt) -- 使得每一个新建的set有相同的元表 for _,v in ipairs(arr) do -- 注意这里要记录的是v set[v] = true end return set end -- 集合并集 function Set.union(a,b) -- if getmetatable(a)~=mt or getmetatable(b)~=mt then -- error(\u0026#34;matetable is mismathching\u0026#34;) -- end local res = Set.new({}) -- 注意这里括号里要传一个table,否则new参数为nil无法构成迭代器而报错;或者new里对传参作缺省处理; for k in pairs(a) do res[k] = true end for k in pairs(b) do res[k] = true end return res end -- 集合交集 function Set.intersection(a,b) local res = Set.new({}) for k in pairs(a) do res[k] = b[k] end return res end -- 转换为字符串 function Set.tostring(set) local list = {} for e,_ in pairs(set) do list[#list + 1] = tostring(e) end -- table.sort(list) -- 显示时可以排个序方便观察，只是显示并没有对set内部产生任何影响 return \u0026#34;{\u0026#34; .. table.concat(list,\u0026#39;,\u0026#39;) .. \u0026#34;}\u0026#34; end -- 构建一个有序set function Set.sort(set) local st = {} for k,_ in pairs(set) do st[#st + 1] = k end table.sort(st) return setmetatable(st,mt) -- 这里只能重新构建一个有相同元表的“类Set“对象才能保证是一个有序set end -- 为元表添加元方法 -- 方式1 mt.__add = Set.union mt.__sub = Set.intersection mt.__tostring = Set.tostring -- 使得使用print输出直接为我们Set.tostring中设定的格式，因为print会自动调用tostring; -- 当使用io.write输出是需要显示调用tostring，即：io.write(tostring(set_obj)) -- 方式2 -- 子集：\u0026lt;= ，结合Set底层实现来编写比较逻辑 mt.__le = function (a,b) for k,_ in pairs(a) do if not b[k] then return false end end return true end -- 真子集：\u0026lt; mt.__lt = function (a,b) return a\u0026lt;=b and not (b\u0026lt;=a) end -- 相等： == mt.__eq = function (a,b) return a\u0026lt;=b and b\u0026lt;=a end --[[为了保证元表的安全: -- 即 不被getmetetable获取到真实元表 以及 setmatetable修改我们真实的元表， -- 只需为__metatable赋一个值即可； -- 即getmetetable和setmatetable获取和修改的只是元表中__metatable 的值; -- 思考： 也就是说__metatable 存的是 元表本身（self）？ --]] mt.__metatable = \u0026#34;you can\u0026#39;t get and change really metatable\u0026#34; return Set 测试Set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- D:\\lua_note\\chapter20\\test_set.lua package.path = package.path .. \u0026#39;;../lua_note/chapter20/?.lua\u0026#39; Set = require \u0026#34;set\u0026#34; local s1 = Set.new({1,2,3,4}) local s2 = Set.new({3,4,5,6}) -- local x = {1,4,6,8,9} -- for v in pairs(x) do -- 低版本的lua输出结果是content,lua 5.3输出了数字对应的key -- print(v) -- end print(getmetatable(s1)) print(getmetatable(s1) == getmetatable(s2)) -- true print(s1) -- {1,2,3,4} print(s2) -- {4,5,6,3} -- 可以发现s2乱序了，并不是按我们传入序列的顺序构建的， -- 原因是我们Set底层实现是key=val形式标记元素存在，存储在table底层的hash表中 s3 = s1 + s2 print(s3) -- {1,2,3,4,5,6} s4 = s1 - s2 print(s4) -- {4,3} io.write(tostring(s4)) -- {4,3} print(Set.sort(s2)) -- {1,2,3,4} print(getmetatable(s1) == getmetatable(s2)) -- true print(s4 \u0026lt;= s1) -- true print(s4 \u0026lt; s1) -- true print(Set.sort(s2) == s1) -- true local s3 = s1 + \u0026#34;hello\u0026#34; -- error print(s3) local s2 = s1 + 8 -- error print(s2) __index 如果访问table中没有定义的元素，经常返回nil; 原因： 访问字段是通过调用元函数__index来完成的，然而一般这个函数没有定义，所以我们访问没有定义的元素得到的是nil; 用途： 我们可以定义这个元函数来改变这种行为(比如访问一个不存在的元素时访问一个默认值)； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 local tb = {1111,x = 1,g = 10} local mt = {x = 2,y = 3} -- 访问一个不存在的元素时返回一个默认值 mt.__index = function () return \u0026#34;hhh\u0026#34; end print(tb.haaa,tb.ha,mt.la) -- hhh hhh nil local mt = {} function new(tb) setmetatable(tb,mt) return tb end local proto = {x = 1,y = 2,width = 3,height = 4} mt.__index = function (_,key) -- key作为第二个参数，思考：第一个参数是什么？ tip: 这种方式更复杂但更灵活，可以实现多继承； return proto[key] end local w = new{x = 10,y = 20} print(w.width) -- 3 local mp = {left = 1024,right = 2048} mt.__index = mp -- 也可以直接是一个table，这样相当于实现了单继承，继承了mp中的特性 print(w.left) -- 1024 访问表中元素的顺序: 先访问原始表，如果找到则直接返回，否则访问（调用）元表中的__index； rawget(tb,index)：即只读原始表，不访问(调用)元表中的__index; 1 2 3 4 5 6 7 8 local tb = {x = 1,g = 10} local mt = {__index = {x = 2,y = 3},z = 4} setmetatable(tb,mt) print(tb.x,tb.y,tb.z) -- 1 3, nil,从这里可以看出访问元素的顺序 print(tb.x,tb.y) -- 1 3 --原始表中没有y,去元表中访问（调用）__index print(rawget(tb,\u0026#34;x\u0026#34;),rawget(tb,\u0026#34;y\u0026#34;)) -- 1 nil，可见rawget不会访问__index __newindex 当我们给table中一个不存在的 index 赋值时， 如果定义了__newindex,则会调用这个元函数而不是直接进行赋值操作,可以借助这个特性保证table只可读; 和__index类似，如果这个元方法被赋值为另一个table,则不会对原table起作用，而是操作 赋值给这样元方法的table； 1 2 3 4 5 6 7 8 9 10 11 12 13 -- read only table function MakeReadOnly(t) mt = {} mt.__index = t mt.__newindex = function () error(\u0026#34;read only\u0026#34;) end return setmetatable(t,mt) end local t = {[\u0026#34;A\u0026#34;] = 1,[\u0026#34;B\u0026#34;] = 2,[\u0026#34;C\u0026#34;] = 1024,D = 2048} MakeReadOnly(t) t[\u0026#39;E\u0026#39;] = \u0026#34;hhhh\u0026#34; --error ： read only 不执行__newindex元方法的赋值操作： rawset(tb,k,v) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 local tb = {} local mt = { __newindex = function (tb,k,v) rawset(tb,k,v) print(\u0026#34;use newindex \u0026#34;,tb.b) end } print(\u0026#34;without matetable\u0026#34;) tb.a = 1 print(tb.a) setmetatable(tb,mt) print(\u0026#34;with matetable\u0026#34;) tb.b = 2 print(\u0026#34;direct rawset\u0026#34;) rawset(tb,\u0026#34;c\u0026#34;,3) print(tb.c) --[[output: without matetable 1 with matetable use newindex 2 direct rawset 3 --]] __call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- __call：当一个table当作函数调用时执行 local tb = {10,40,2,3,5} local mt = { __call = function (t,_) local sum = 0 for _,v in ipairs(t) do sum = sum + v; end print(\u0026#39;_ = \u0026#39;,_,\u0026#34;, sum = \u0026#34;,sum) return sum end } setmetatable(tb,mt) tb() -- _ = nil , sum = 60 tb(\u0026#34;test other\u0026#34;) -- _ = test other , sum = 60 -- call赋值的函数第一参数就是原来的表，后面可以有其他参数 ","date":"2021-07-21T00:00:00Z","permalink":"https://example.com/p/lua-metatables-and-metamethods/","title":"lua-metatables and  metamethods"},{"content":"函数调用形式 一般函数调用都要加括号,但是又两种特殊情况不需要：\ncase 1: 传的参数的是 一个 字符串（不是用变量保留的字符串） case 2: 传的参数的是 一个 表的构造 {} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 print(os.date()) print \u0026#34;hello lua\u0026#34; function test_case1(str) assert(type(str) == \u0026#34;string\u0026#34;,\u0026#34;args must be a string\u0026#34;) print(str) end function test_case2(tb) assert(type(tb) == \u0026#34;table\u0026#34;,\u0026#34;args must be a table\u0026#34;) for k,v in ipairs(tb) do print (k,v) end end test_case1 \u0026#34;lua ~ \u0026#34; test_case2 {1,2,3} 函数特性 可以多返回值 函数参数个数可以不定的，参数列表 用 \u0026ldquo;\u0026hellip;\u0026rdquo; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 line = function () -- lambda 函数 print(string.rep(\u0026#39;-\u0026#39;,15)) end line() -- 函数可以返回多个值 function get_max_min(list) min = math.maxinteger max = math.mininteger for _,v in ipairs(list) do max = math.max(max,v) -- max 和 min 函数在低版本的 lua 没有 min = math.min(min,v) end return max,min end a = {2,5,7,3,9,8,1} print(get_max_min(a)) -- 函数参数个数可以不定的，参数列表 用 \u0026#34;...\u0026#34; function my_max(...) max = math.mininteger for _,v in ipairs(...) do max = math.max(max,v) end return max end print(my_max(a)) line() -- 对于 选择 序列 哪部分内容 可以 用 select print(select(2,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;)) --从第 2 个开始选择;output: b c print(type(select(2,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;))) -- string print(type(select(2,1,2,3))) -- number x,y = select(2,1,2,3) print(x,y) -- 2 3 print(select(\u0026#39;#\u0026#39;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;)) -- 若第一个参数为字符 \u0026#39;#\u0026#39;，则返回之后序列的长度，output: 3 -- select 可用于计算不定参数的个数 以及对她进行选择 function select_test(...) sum = 0 for i = 1,select(\u0026#39;#\u0026#39;,...) do sum = sum + select(i,...) -- 此时计算 只会加上所选序列的第一个数，之后的自动忽略 end return sum end print(select_test(1,2,3,4,5)) line() --[[ --注意：select(1,...)返回的是一个序列，但是这里是不可以迭代，思考： ipairs 和 pairs 只能适用于 table ? function select_test2(...) sum = 0 for _,v in ipairs(select(1,...)) do -- error： ipairs(select(1,...)) 不是一个可迭代对象 sum = sum + v end return sum end print(select_test2(1,2,3,4,5)) --]] ","date":"2021-07-19T00:00:00Z","permalink":"https://example.com/p/lua-function/","title":"lua-function"},{"content":"table的key以及存储机制 {}表示table,它可以以除nil外的任何对象作为key； table的底层由 数组 和 hash表 构成；\n当增加一个很大的key使得存储空间利用率低于50%时，这个key会被hash，然后放入hash表存储；\n0，负数，string 作为key时都是被放在hash表存储；\ntable的底层的 数组 或者 hash表 满时，都是以2倍扩容；\nhash表大小是2的倍数，只有当hash表满了，才会重新分配 数组和 hash表的空间；\nref:https://blog.csdn.net/zr339361504/article/details/52432163\ntable计算长度: 采用#table_name 计算table长度\n注意：\n对于带nil的列表，用#计算其长度是不可靠的, 所以它只适用于没有nil的列表; 没有正整数作为key的列表长度为0； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 b = {1,5,nil,10,nil,1024,nil,nil} print(#b) -- 6 c = {1,5,nil,10,nil,1024,nil,nil,x = 3} print(#c) -- 6 -- 以上两种 发现是返回最后不是nil处的index d = {1,5,nil,10,nil,1024,nil,nil,x = 3,233} -- 等价于计算{1,5,nil,10,nil,1024,nil,nil,233} print(#d) -- 9 -- 发现键值对的并没有算进去，因为它存在底层的hash表中，#此时只计算底层的array的长度 e = {x = 1,y = 2,[\u0026#39;z\u0026#39;] = 3} print(#e) -- 0 f = {x = 1,y = 2,[1] = 2} print(#f) --1 g = {x = 2,[2.1] = 3,[-1] = 3} print(#g) --0,发现并没有计算hash表部分 #求长度伪代码： 1 2 3 4 5 6 7 8 9 if 数组最后一位 == nil then 则二分查找往前找到一个不是nil的返回长度 else if 数组最后一位 ~=nil and 散列桶部分 == nil then return 数组长度 else 计算散列桶部分的长度 local function 计算散列桶部分的长度() 从数组长度+1 开始查找, 同样二分查找 （只针对散列桶部分的key为正整数的数据） end 所以使用table时：\n尽量放同一类元素，不要 使得 底层的array 和hash表 都被使用; 存在nil的table 求长度不稳定; 尽量使用数组部分，尽量避免重新散列操作（hash表满后 会 重新分配底层的array和hash表的内存，严重影响效率）; table 的遍历方式 方式1: 1 2 3 4 5 print(\u0026#39;-----normal--------\u0026#39;) -- 与ipairs 等价： 遇到nil终止无法遍历到 键值对元素 for i = 1 , #tb do print(i , tb[i]) end 方式2： 1 2 3 4 5 -- ipairs 遇到nil终止，无法遍历到 键值对元素 print(\u0026#34;-----ipairs--------\u0026#34;) for k,v in ipairs(tb) do print(k,v) end 方式3： 1 2 3 4 5 -- k,v形式遍历table,能遍历到所有元素 print(\u0026#34;-----paris--------\u0026#34;) for k,v in pairs(tb) do print(k,v) end 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 tb = {} tb[\u0026#39;x\u0026#39;] = 1 tb[2.1] = 2021 print(tb[2.1],tb.x) tb[2] = 2 print(tb[2]) -- table是匿名对象，保存table的变量是对表的引用，当表的引用计数为0时会被gc自动回收 tb2 = tb tb = nil print(tb2[\u0026#39;x\u0026#39;]) -- 依然有效 tb2.y = 10 -- 等价于tb2[\u0026#39;y\u0026#39;] = 10 print(tb2.y,tb2[\u0026#39;y\u0026#39;]) -- table 构造列表可以是 单个值 以及 键值对 的形式 list = {x = 1,\u0026#34;hello\u0026#34;,y = 2,math.pi} print(list.x) -- 注意: 构造列表，起始索引1 从 第一个 非键值对的元素 算起,依次对这类元素进行index++ print(list[0],list[1]) -- nil hello print(list[2],list[-1]) -- 3.1415926535898 nil list[-1] = 1024 list[0] = 2021 list[1] = \u0026#34;world\u0026#34; -- k,v形式遍历table,能遍历到所有元素 print(\u0026#34;-----paris--------\u0026#34;) for k,v in pairs(list) do print(k,v) end -- ipairs 遇到nil终止，无法遍历到 键值对元素 print(\u0026#34;-----ipairs--------\u0026#34;) for k,v in ipairs(list) do print(k,v) end --[[ output: -----paris-------- 1 world 2 3.1415926535898 y 2 x 1 -1 1024 0 2021 -----ipairs-------- 1 world 2 3.1415926535898 --]] print(\u0026#39;-----normal--------\u0026#39;) -- ipairs 等价于以下我们常用的方式: for i = 1 , #list do print(i , list[i]) end 常用函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 --useful functions in table library -- 增加 和 移除 t = {1,2,3,4,5,6} print(t[6]) table.insert(t,6,7) -- table, pos ，val print(t[6],t[7]) x = table.remove(t,7) -- table，pos,返回该位置的值 print(x) table.insert(t,8) -- table,val ：默认插在最后 print(t[#t]) --[[ t = {} for line in io.lines() do -- ctrl+z 结束输入 table.insert(t,line) end print(#t) for k,v in pairs(t) do print(k,v) end --]] print(string.rep(\u0026#39;-\u0026#39;,10)) function print_table(a) for k,v in ipairs(a) do print(k,v) end end -- 移动元素 a = {1,2,3,4,5,6} -- move在5.3版本有，但是之前的5.1版本却不存在 print(#a) table.move(a,1,#a,2) -- a[1...#a] = a[2...2+#a],即整体后移一位 print(#a) print_table(a) -- 可以发现空出的位置a[1]的值没有发生变化 print(string.rep(\u0026#39;-\u0026#39;,10)) a[1] = 1024 --这时相当于 头部 增加一个元素 table.move(a,2,#a,1) print_table(a) -- 空出的位置a[#a]值 依然不变,a[1]位置上的值被覆盖了 print(#a) a[#a] = nil -- 尾部置nil,此时 真正意义上 删掉了一个元素 而且 是 头部元素 print(#a) -- 由上面两个测试 可以大致推断table中move 实现 function move(a,s,e,pos) if pos == s then return a end while s \u0026lt;= e do a[pos] = a[s] pos = pos + 1 s = s + 1 end return a end print(string.rep(\u0026#39;-\u0026#39;,10)) a = {1,2,3,4,5,6} -- print(table.move(a,3,5,2) == move(a,3,5,2)) -- true -- print_table(a) -- after: {1,3,4,5,5,6} print(table.move(a,1,#a,2) == move(a,1,#a,2)) -- true print_table(a) print(string.rep(\u0026#39;-\u0026#39;,10)) b = {2,6,7,3,9,2,1} -- 排序 : 默认升序 table.sort(b) print_table(b) print(string.rep(\u0026#39;-\u0026#39;,10)) -- 自己写比较规则 table.sort(b,function (a,b) return a \u0026gt; b -- 降序 end) print_table(b) -- 将元素连接成一个字符串 print(table.concat(b,\u0026#39;-\u0026#39;,1,#b)) ","date":"2021-07-19T00:00:00Z","permalink":"https://example.com/p/lua-table/","title":"lua-table"}]